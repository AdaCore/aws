<html lang="en">
<head>
<title>Templates Parser User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="Templates Parser User's Guide">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<h1>Templates Parser User's Guide</h1>
<font size="+2">
<p>$Revision$
<p>Date: 14 December 2004
<p>Pascal Obry (pascal@obry.org)
</font>

<font size="+1">
<p>&lt;<code>http://www.obry.org</code>&gt;
</font>


<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top"></a>
    <a href="#Top">Templates Parser</a>
<li><a name="toc_Introduction"></a>
    <a href="#Introduction">Introduction</a>
<li><a name="toc_What%20is%20a%20tag%20%3f"></a>
    <a href="#What%20is%20a%20tag%20%3f">What is a tag ?</a>
<li><a name="toc_Variable%20tags"></a>
    <a href="#Variable%20tags">Variable tags</a>
<ul>
<li><a href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>
<li><a href="#Filters%20and%20Attributes">Filters and Attributes</a>
<ul>
<li><a href="#Filters">Filters</a>
<li><a href="#Attributes">Attributes</a>
</ul>
<li><a href="#Other%20variable%20tags">Other variable tags</a>
</ul>
<li><a name="toc_Translations"></a>
    <a href="#Translations">Translations</a>
<li><a name="toc_Tag%20statements"></a>
    <a href="#Tag%20statements">Tag statements</a>
<ul>
<li><a href="#Comments%20tag%20statement">Comments tag statement</a>
<li><a href="#INCLUDE%20tag%20statement">INCLUDE tag statement</a>
<li><a href="#IF%20tag%20statement">IF tag statement</a>
<li><a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li><a href="#SET%20tag%20statement">SET tag statement</a>
</ul>
<li><a name="toc_Other%20services"></a>
    <a href="#Other%20services">Other services</a>
<ul>
<li><a href="#Context">Context</a>
<li><a href="#Tag%20utils">Tag utils</a>
<li><a href="#XML%20representation">XML representation</a>
<li><a href="#Debug">Debug</a>
</ul>
<li><a name="toc_Last%20notes"></a>
    <a href="#Last%20notes">Last notes</a>
<li><a name="toc_Templates_Parser%20API%20Reference"></a>
    <a href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>
<ul>
<li><a href="#Templates_Parser">Templates_Parser</a>
<li><a href="#Templates_Parser.Debug">Templates_Parser.Debug</a>
<li><a href="#Templates_Parser.Utils">Templates_Parser.Utils</a>
<li><a href="#Templates_Parser.XML">Templates_Parser.XML</a>
</ul>
<li><a name="toc_Index"></a>
    <a href="#Index">Index</a>
</ul>

<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next accesskey=n href="#Introduction">Introduction</a>,
Up:<a rel=up accesskey=u href="#dir">(dir)</a>
<br>

<h2>Templates Parser</h2>

<ul>
<li><a accesskey=1 href="#Introduction">Introduction</a>: 
<li><a accesskey=2 href="#What%20is%20a%20tag%20%3f">What is a tag ?</a>: 
<li><a accesskey=3 href="#Variable%20tags">Variable tags</a>: 
<li><a accesskey=4 href="#Translations">Translations</a>: 
<li><a accesskey=5 href="#Tag%20statements">Tag statements</a>: 
<li><a accesskey=6 href="#Other%20services">Other services</a>: 
<li><a accesskey=7 href="#Last%20notes">Last notes</a>: 
<li><a accesskey=8 href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>: 
<li><a accesskey=9 href="#Index">Index</a>: 
</ul>

<p><hr>
Node:<a name="Introduction">Introduction</a>,
Next:<a rel=next accesskey=n href="#What%20is%20a%20tag%20%3f">What is a tag ?</a>,
Previous:<a rel=previous accesskey=p href="#Top">Top</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Introduction</h2>

<p>First of all this package is distributed under the GNAT modified GNU GPL.

<p>The templates parser package has been designed to parse files and to
replace some specific tags into these files by some specified values.

<p>The main goal was to ease the development of Web servers. In CGI
(<i>Common Gateway Interface</i>) mode you have to write the HTML page in
the program (in Ada or whatever other languages) by using some specific
libraries or by using only basic output functions like Ada <code>Put_Line</code> for
example. This is of course not mandatory but by lack of a good library
every Web development end up doing just that.

<p>The main problems with this approach are:

<ul>

<li>It is painful to have to recompile the program each time you have
a slight change to do in the design (center an image, change the border
width of a table...)

<li>You have the design and the program merged together. It means that
to change the design you must know the Ada language. And to change the
Ada program you need to understand what is going on with all these
inline HTML command.

<li>You can't use the nice tools to generate your HTML.

</ul>

<p>With the templates parser package these problems are gone. The code and
the design is <b>completely</b> separated. This is a very important
point. PHP or JSP have tried this but most of the time you have the
script embedded into the Web template. And worst you need to use another
language just for your Web development.

<ul>

<li>The HTML page is separated from the program code. Then you can
change the design without changing the code. Moreover when you fix the
code you don't have to handle all the specific HTML output. And you do
not risk to break the design.

<li>It is easier to work on the design and the program at the same time
using the right peoples for the job.

<li>It reduce the number of <i>edit/build/test</i> cycles. Writing HTML
code from a program is error prone.

<li>It is possible to use standard tools to produce the HTML.

<li>You don't have to learn a new language.

<li>The script is Ada, so here you have the benefit of all the Ada power.

</ul>

<p>In fact, now the Ada program just compute some values, get some data
from a database or whatever and then call the templates parser to output
a page with the data displayed. To the templates parser you just pass
the template filename and an associative table.

<p>It is even more convenient to have different display with the same set
of data. You just have to provides as many templates as you like.

<p><hr>
Node:<a name="What%20is%20a%20tag%20%3f">What is a tag ?</a>,
Next:<a rel=next accesskey=n href="#Variable%20tags">Variable tags</a>,
Previous:<a rel=previous accesskey=p href="#Introduction">Introduction</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>What is a tag ?</h2>

<p>A tag is a string found in the template page and surrounded by a specific set
of characters. The default is <b>@_</b> at the start and <b>_@</b> at the
end of the tag. This default can be changed using <code>Set_Tag_Separators</code>
routine, see <a href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>. Note that it must be changed
as the first API call and should not be changed after that.

<p>The tag will be replaced by a value specified in a translation table.

<p>For example with the template file <code>demo.tmplt</code>:

<br><pre>

&lt;P&gt;Hello @_NAME_@
</pre>

<p>Using the following code <code>demo.adb</code>:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> Demo <b>is</b>

   Translations : <b>constant</b> Templates_Parser.Translate_Table
     := (1 =&gt; Templates_Parser.Assoc ("<i>NAME</i>", "<i>Ada</i>"));

<b>begin</b>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>demo.tmplt</i>", Translations));
<b>end</b> Demo;
</pre>

<p>The program will print out :

<br><pre>
&lt;P&gt;Hello Ada
</pre>

<p>This is a very simple example, but you'll see that there is a lot of
powerful construct that you can use into a template file.

<p><hr>
Node:<a name="Variable%20tags">Variable tags</a>,
Next:<a rel=next accesskey=n href="#Translations">Translations</a>,
Previous:<a rel=previous accesskey=p href="#What%20is%20a%20tag%20%3f">What is a tag ?</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Variable tags</h2>

<ul>
<li><a accesskey=1 href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>: 
<li><a accesskey=2 href="#Filters%20and%20Attributes">Filters and Attributes</a>: 
<li><a accesskey=3 href="#Other%20variable%20tags">Other variable tags</a>: 
</ul>

<p><hr>
Node:<a name="Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>,
Next:<a rel=next accesskey=n href="#Filters%20and%20Attributes">Filters and Attributes</a>,
Up:<a rel=up accesskey=u href="#Variable%20tags">Variable tags</a>
<br>

<h3>Discrete Boolean Composite</h3>

<p>A variable tag is a specific string to be replaced by the template
parser. There is three kinds of variable tags: <b>discrete</b>, <b>boolean</b>,
<b>composite</b>. All variables tags are built using the <code>Assoc</code>
constructors, see <a href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>.

<dl>

<br><dt><b>discrete</b>
<dd>We have already seen the discrete variable tag. This is a variable which
has only one value. This value will replace the tag in the template
file. Discrete variable constructors are provided for String,
Unbounded_String and Integer (see Assoc routines).
<br><p>
<br><dt><b>boolean</b>
<dd>A boolean tag as a value of TRUE or FALSE. This value will replace the
tag in the template file. These tags can also be used with the <code>IF</code> tag
statement.
<br><p>
<br><dt><b>composite (Tag)</b>
<dd>A composite tag is a variable which contains a set of values. These kind of
variables will be used with the <code>TABLE</code> tag statement
see <a href="#TABLE%20tag%20statement">TABLE tag statement</a>. Outside a table statement it will be
replaced by all values concatenated with a specified separator. See
<code>Set_Separator</code> routine. Such tag are variables declared on the
Ada program a <code>Templates_Parser.Tag</code> type.

<br><p>
<p>There is many overloaded constructors to build a composite tags (see "+"
operators).  The "+" operators are used to build a Tag item from
standard types like String, Unbounded_String, Character, Integer and
Boolean.

<br><p>
<p>To add items to a Tag many overloaded operators are provided (see
"&amp;" operators). The "&amp;" operators add one item at the start or the end
of the tag, it is possible to add directly String, Unbounded_String,
Character, Integer and Boolean items using one of the overloaded operator.

<br><p>
<p>A tag composed of only boolean values TRUE or FALSE is called a
Boolean composite tag. This tag is to be used with a <code>IF</code> tag statement
inside a <code>TABLE</code> tag statement.

<br><p>
<p>It is possible to build a composite tag having any number of nested
level. A vector is a composite tag with only one level, a matrix is a
composite tag with two level (a Tag with a set of vector tag).

<br><p>
<p>Two aliases exists for composite tags with one or two nested level,
they are named <code>Vector_Tag</code> and <code>Matrix_Tag</code>. In the suite
of the document, we call <i>vector tag</i> a tag with a single nested
level and <i>matrix tag</i> a tag with two nested level.

</dl>

<p><hr>
Node:<a name="Filters%20and%20Attributes">Filters and Attributes</a>,
Next:<a rel=next accesskey=n href="#Other%20variable%20tags">Other variable tags</a>,
Previous:<a rel=previous accesskey=p href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>,
Up:<a rel=up accesskey=u href="#Variable%20tags">Variable tags</a>
<br>

<h3>Filters and Attributes</h3>

<p>All kinds of variable tag can have one or more function-prefix or
filter. The function prefix is applied to the variable value. The
syntax is
<code>@_[[FILTER_NAME[(parameter)]:]FILTER_NAME[(parameter)]:]SOME_VAR_@</code>. 
Filters are evaluated from right to left.

<p>Composite tags can also have attributes. Attributes are placed
after the tag name and preceded with a simple quote. 
<code>@_SOME_VAR['ATTRIBUTE_NAME]_@</code>. It is possible to use filters
and attributes together. In that case the attribute is first evaluated and
the result is passed-through the filters.

<ul>
<li><a accesskey=1 href="#Filters">Filters</a>: 
<li><a accesskey=2 href="#Attributes">Attributes</a>: 
</ul>

<p><hr>
Node:<a name="Filters">Filters</a>,
Next:<a rel=next accesskey=n href="#Attributes">Attributes</a>,
Up:<a rel=up accesskey=u href="#Filters%20and%20Attributes">Filters and Attributes</a>
<br>

<h4>Filters</h4>

<p>The current supported filters are:

<dl>

<br><dt><code>"+"(<i>N</i>) or ADD(<i>N</i>)</code>
<dd>

<p>Add N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<br><dt><code>"-"(<i>N</i>) or SUB(<i>N</i>)</code>
<dd>

<p>Subtract N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<br><dt><code>"*"(<i>N</i>) or MULT(<i>N</i>)</code>
<dd>

<p>Multiply N with variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<br><dt><code>"/"(<i>N</i>) or DIV(<i>N</i>)</code>
<dd>

<p>Divide variable by N and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<br><dt><code>ABS</code>
<dd>

<p>Returns the absoute value.

<br><dt><code>ADD_PARAM(<i>NAME[=VALUE]</i>)</code>
<dd>

<p>Add a parameter into an URL. This routine adds the '?' and '&amp;'
character if needed. <i>VALUE</i> can be a tag variable name.

<br><dt><code>BR_2_LF</code>
<dd>

<p>Replaces all occurrences of the <code>&lt;br&gt;</code> HTML tag by a LF
(Line-Feed) character.

<br><dt><code>CAPITALIZE</code>
<dd>

<p>Put all characters in the variable in lower case except characters after
a space or an underscore which are set in upper-case.

<br><dt><code>CLEAN_TEXT</code>
<dd>

<p>Keep only letters and digits all others characters are changed to
spaces.

<br><dt><code>COMA_2_POINT</code>
<dd>

<p>Replaces all comas by points.

<br><dt><code>CONTRACT</code>
<dd>

<p>Converts any suite of spaces by a single space character.

<br><dt><code>DEL_PARAM(<i>NAME</i>)</code>
<dd>

<p>Delete parameter NAME from the URL. This routine removes the '?' and '&amp;'
character if needed. Returns the input string as-is if the parameter
is not found.

<br><dt><code>EXIST</code>
<dd>

<p>Returns <b>True</b> if variable is set and has a value different that the null
string and <b>False</b> otherwise.

<br><dt><code>FILE_EXISTS</code>
<dd>

<p>Returns <b>True</b> if variable is set and has a value that corresponds
to a filename present on the file system and <b>False</b> otherwise.

<br><dt><code>FORMAT_DATE(<b>FORMAT</b>)</code>
<dd>

<p>Returns the date with the given format. The date must be in the ISO
format (YYYY-MM-DD) eventually followed by a space and the time with
the format HH:MM:SS. If the date is not given in the right format it
returns the date as-is. The format is using the GNU/date description
patterns as also implemented in <code>GNAT.Calendar.Time_IO</code>.

<br><p>
<br><p>
<dl>

<br><dt><i>Characters:</i>
<dd>
<dl>
<dt><b>%</b>
<dd>a literal %
<br><dt><b>n</b>
<dd>a newline
<br><dt><b>t</b>
<dd>a horizontal tab
</dl>

<br><dt><i>Time fields:</i>
<dd>
<dl>
<dt><b>%H</b>
<dd>hour (00..23)
<br><dt><b>%I</b>
<dd>hour (01..12)
<br><dt><b>%k</b>
<dd>hour ( 0..23)
<br><dt><b>%l</b>
<dd>hour ( 1..12)
<br><dt><b>%M</b>
<dd>minute (00..59)
<br><dt><b>%p</b>
<dd>locale's AM or PM
<br><dt><b>%r</b>
<dd>time, 12-hour (hh:mm:ss [AP]M)
<br><dt><b>%s</b>
<dd>seconds  since 1970-01-01  00:00:00 UTC (a nonstandard extension)
<br><dt><b>%S</b>
<dd>second (00..59)
<br><dt><b>%T</b>
<dd>time, 24-hour (hh:mm:ss)
</dl>

<br><dt><i>Date fields:</i>
<dd>
<dl>
<dt><b>%a</b>
<dd>locale's abbreviated weekday name (Sun..Sat)
<br><dt><b>%A</b>
<dd>locale's full weekday name, variable length (Sunday..Saturday)
<br><dt><b>%b</b>
<dd>locale's abbreviated month name (Jan..Dec)
<br><dt><b>%B</b>
<dd>locale's full month name, variable length (January..December)
<br><dt><b>%c</b>
<dd>locale's date and time (Sat Nov 04 12:02:33 EST 1989)
<br><dt><b>%d</b>
<dd>day of month (01..31)
<br><dt><b>%D</b>
<dd>date (mm/dd/yy)
<br><dt><b>%h</b>
<dd>same as %b
<br><dt><b>%j</b>
<dd>day of year (001..366)
<br><dt><b>%m</b>
<dd>month (01..12)
<br><dt><b>%U</b>
<dd>week number of year with  Sunday as first day of week (00..53)
<br><dt><b>%w</b>
<dd>day of week (0..6) with 0 corresponding to Sunday
<br><dt><b>%W</b>
<dd>week number of year with  Monday as first day of week (00..53)
<br><dt><b>%x</b>
<dd>locale's date representation (mm/dd/yy)
<br><dt><b>%y</b>
<dd>last two digits of year (00..99)
<br><dt><b>%Y</b>
<dd>year (1970...) 
</dl>

<br><dt><i>By default,  date pads numeric fields with zeroes. GNU date recognizes the following nonstandard numeric modifiers:</i>
<dd>
<dl>
<dt><b>-    (hyphen)</b>
<dd>do not pad the field
<br><dt><b>_    (underscore)</b>
<dd>pad the field with spaces
</dl>
</dl>

<br><dt><code>FORMAT_NUMBER</code>
<dd>

<p>Returns the number with a space added between each 3 digits
blocks. The decimal part is not transformed. If the data is not a
number nothing is done.

<br><dt><code>IS_EMPTY</code>
<dd>

<p>Returns <b>True</b> if variable is the empty string and <b>False</b> otherwise.

<br><dt><code>LF_2_BR</code>
<dd>

<p>Replaces all occurrences of the character LF (Line-Feed) by a
<code>&lt;br&gt;</code> HTML tag.

<br><dt><code>LOWER</code>
<dd>

<p>Put all characters in the variable in lower-case.

<br><dt><code>MATCH(<i>REGEXP</i>)</code>
<dd>

<p>Returns <b>True</b> if variable match the regular expression passed as
filter's parameter. The regular expression is using a format as
found in <code>gawk</code>, <code>sed</code> or <code>grep</code> tools.

<br><dt><code>MAX(<i>N</i>)</code>
<dd>

<p>Returns the maximum value between the variable and the parameter.

<br><dt><code>MIN(<i>N</i>)</code>
<dd>

<p>Returns the minimum value between the variable and the parameter.

<br><dt><code>MOD(<i>N</i>)</code>
<dd>

<p>Returns variable modulo N. If the current variable value is not a
number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<br><dt><code>NEG</code>
<dd>

<p>Change the sign of the value.

<br><dt><code>NO_CONTEXT</code>
<dd>

<p>This is a special command filter which indicates that the tag must not
be searched in the context. See see <a href="#Context">Context</a>. <code>NO_CONTEXT</code> must be
the first filter. This filter returns the value as-is.

<br><dt><code>NO_DIGIT</code>
<dd>

<p>Replaces all digits by spaces.

<br><dt><code>NO_LETTER</code>
<dd>

<p>Replaces all letters by spaces.

<br><dt><code>NO_SPACE</code>
<dd>

<p>Removes all spaces in the variable.

<br><dt><code>OUI_NON</code>
<dd>

<p>If variable value is <b>True</b> it returns <b>Oui</b>, if <b>False</b> it
returns <b>Non</b>, otherwise does nothing. It keeps the way <b>True/False</b> is
capitalized (all upper, all lower or first letter capital).

<br><dt><code>POINT_2_COMA</code>
<dd>

<p>Replaces all comas by points.

<br><dt><code>REPEAT(<i>N</i>)</code>
<dd>

<p>Returns N times the variable, N being passed as filter's parameter. N
must be a number  or a discrete tag variable whose value is a number.

<br><dt><code>REPLACE(<i>REGEXP</i>[/<i>STR</i>])</code>
<dd>

<p>This filter replaces <b>\n</b> (where <i>n</i> is a number) <i>STR</i>'s
occurences by the corresponding match from <i>REGEXP</i>. The first match
in <i>REGEXP</i> will replace <b>\1</b>, the second match <b>\2</b> and so
on. Each match in <i>REGEXP</i> must be parenthesized. It replaces only
the first match. <i>STR</i> is an optional parameter, its default value
is <b>\1</b>. It is possible to espace characters in <i>STR</i> to avoid
parsing confusions. This is required if you need to have <b>@_</b> or
<b>_@</b> or a parenthesis in <i>STR</i> for example. <i>STR</i> can be a tag
variable name.

<br><dt><code>REPLACE_ALL(<i>REGEXP</i>[/<i>STR</i>])</code>
<dd>

<p>Idem as above but replaces all occurences.

<br><dt><code>REPLACE_PARAM(<i>NAME[=VALUE]</i>)</code>
<dd>

<p>This is filter is equivalent to
ADD_PARAM(<i>NAME[=VALUE]</i>):DEL_PARAM(<i>NAME</i>). <i>VALUE</i> can be a
tag variable name.

<br><dt><code>REVERSE</code>
<dd>

<p>Reverse the string.

<br><dt><code>SIZE</code>
<dd>

<p>Returns the size (number of characters) of the string value.

<br><dt><code>SLICE(<i>x .. y</i>)</code>
<dd>

<p>Returns the sub-string starting from position x and ending to position
y. Note that the string to slice always start from position 1.

<br><dt><code>TRIM</code>
<dd>

<p>Removes leading and trailing spaces.

<br><dt><code>UPPER</code>
<dd>

<p>Put all characters in the variable in upper-case.

<br><dt><code>WEB_ESCAPE</code>
<dd>

<p>Replaces characters '&lt;', '&gt;', '"' and '&amp;' by corresponding HTML
sequences: &amp;lt; &amp;gt; &amp;quot; and &amp;amp;

<br><dt><code>WEB_NBSP</code>
<dd>

<p>Replaces all spaces by an HTML non breaking space.

<br><dt><code>YES_NO</code>
<dd>

<p>If variable value is <b>True</b> it returns <b>Yes</b>, if <b>False</b> it
returns <b>No</b>, otherwise does nothing. It keeps the way <b>True/False</b> is
capitalized (all upper, all lower or first letter capital).

</dl>

<p>For example:

<br><pre>
If VAR is set to "<i>vector_tag</i>", ONE to "1" and TWO to "2" then:


@_VAR_@                                   -&gt;  vector_tag
@_UPPER:VAR_@                             -&gt;  VECTOR_TAG
@_CAPITALIZE:VAR_@                        -&gt;  Vector_Tag
@_EXIST:VAR_@                             -&gt;  TRUE
@_UPPER:REVERSE:VAR_@                     -&gt;  GAT_ROTCEV
@_MATCH(VEC.*):UPPER:VAR_@                -&gt;  TRUE
@_SLICE(1..6):VAR_@                       -&gt;  vector
@_REPLACE(([^_]+)):VAR_@                  -&gt;  vector
@_REPLACE(([a-z]+)_([a-z]+)/\2_\1):VAR_@  -&gt;  tag_vector
@_"+"(TWO):ONE_@                          -&gt;  3
@_"-"(TWO):ONE_@                          -&gt;  -1
</pre>

<p><hr>
Node:<a name="Attributes">Attributes</a>,
Previous:<a rel=previous accesskey=p href="#Filters">Filters</a>,
Up:<a rel=up accesskey=u href="#Filters%20and%20Attributes">Filters and Attributes</a>
<br>

<h4>Attributes</h4>

<p>Current supported attributes are:

<dl>

<br><dt><code>V'length</code>
<dd>

<p>Returns the number of item in the composite tag (can be applied only
to a composite tag having a single nested level - a vector).

<br><dt><code>V'Up_Level(n)</code>
<dd>

<p>Use index from the table command <b>n</b> level(s) upper so this attribute must
be used in a nested table command tag. <code>'Up_Level</code> is equivalent
to <code>'Up_Level(1)</code> (can be applied only to a composite tag having
a single nested level - a vector).

<br><dt><code>M'Line</code>
<dd>

<p>Returns the number of line in the composite tag. This is identical to
'Length but can be applied only to a composite tag having two nested
level - a matrix).

<br><dt><code>M'Min_Column</code>
<dd>

<p>Returns the size of smallest composite tag in M composite tag. This attribute
can be applied only to a composite tag having two nested level - a matrix.

<br><dt><code>M'Max_Column</code>
<dd>

<p>Returns the size of largest composite tag in M composite tag. This attribute
can be applied only to a composite tag having two nested level - a matrix.

</dl>

<p>For example:

<br><pre>
If VEC is set to "<i>&lt;1 , 2&gt;</i>" and MAT to "<i>&lt;a, b, c&gt; ; &lt;2, 3, 5, 7&gt;</i>" then:


@_VEC'Length_@              -&gt;  2
@_ADD(3):VEC'Length_@       -&gt;  5
@_MAT'Line_@                -&gt;  2
@_MAT'Min_Column_@          -&gt;  3
@_MAT'Max_Column_@          -&gt;  4
</pre>

<p><hr>
Node:<a name="Other%20variable%20tags">Other variable tags</a>,
Previous:<a rel=previous accesskey=p href="#Filters%20and%20Attributes">Filters and Attributes</a>,
Up:<a rel=up accesskey=u href="#Variable%20tags">Variable tags</a>
<br>

<h3>Other variable tags</h3>

<p>There is some specific variables tags that can be used in any
templates. Here is a description of them:

<dl>

<br><dt><code>NOW</code>
<dd>

<p>Current date and time with format "YYYY-MM-DD HH:MM:SS".

<br><dt><code>YEAR</code>
<dd>

<p>Current year number using 4 digits.

<br><dt><code>MONTH</code>
<dd>

<p>Current month number using 2 digits.

<br><dt><code>DAY</code>
<dd>

<p>Current day number using 2 digits.

<br><dt><code>HOUR</code>
<dd>

<p>Current hour using range 0 to 23 using 2 digits.

<br><dt><code>MINUTE</code>
<dd>

<p>Current minute using 2 digits.

<br><dt><code>SECOND</code>
<dd>

<p>Current seconds using 2 digits.

<br><dt><code>MONTH_NAME</code>
<dd>

<p>Current full month name (January .. December).

<br><dt><code>DAY_NAME</code>
<dd>

<p>Current full day name (Monday .. Sunday).

</dl>

<p><hr>
Node:<a name="Translations">Translations</a>,
Next:<a rel=next accesskey=n href="#Tag%20statements">Tag statements</a>,
Previous:<a rel=previous accesskey=p href="#Variable%20tags">Variable tags</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Translations</h2>

<p>Associations between variable tags and the template tag names are
created with one of the <code>Assoc</code> routines. This set of
associations are used by the parser (<code>Parse</code> routine). There is
two kinds of associations set:

<ul>

<li>Translate_Table

<p>an array of associations, this is easy to use when the number of
associations is known at the creation time.

</p><li>Translate_Set

<p>a set of associations, it is possible to insert as many associations
as needed into this object. 
</ul>

<p>Note that this difference is only for users, the Templates_Parser
engine uses only <code>Translate_Set</code> objects internally as it is much more
efficient.

<p><hr>
Node:<a name="Tag%20statements">Tag statements</a>,
Next:<a rel=next accesskey=n href="#Other%20services">Other services</a>,
Previous:<a rel=previous accesskey=p href="#Translations">Translations</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Tag statements</h2>

<p>There is three different tag statements. A tag statement is surrounded
by <code>@@</code>. The tag statements are:

<ul>
<li><a accesskey=1 href="#Comments%20tag%20statement">Comments tag statement</a>: 
<li><a accesskey=2 href="#INCLUDE%20tag%20statement">INCLUDE tag statement</a>: 
<li><a accesskey=3 href="#IF%20tag%20statement">IF tag statement</a>: 
<li><a accesskey=4 href="#TABLE%20tag%20statement">TABLE tag statement</a>: 
<li><a accesskey=5 href="#SET%20tag%20statement">SET tag statement</a>: 
</ul>

<p><hr>
Node:<a name="Comments%20tag%20statement">Comments tag statement</a>,
Next:<a rel=next accesskey=n href="#INCLUDE%20tag%20statement">INCLUDE tag statement</a>,
Up:<a rel=up accesskey=u href="#Tag%20statements">Tag statements</a>
<br>

<h3>Comments tag statement</h3>

<p>Every line starting with <b>@@-</b> are comments and are completly
ignored by the parser. The resulting page will have the exact same
format and number of lines with or without the comments.

<br><pre>
@@-- This template is used to display the client's data
@@-- It uses the following tags:
@@--
@@--    @_CID_@       Client ID
@@--    @_ITEMS_V_@   List of items (vector tag)

&lt;P&gt;Client @_CID_@

...
</pre>

<p><hr>
Node:<a name="INCLUDE%20tag%20statement">INCLUDE tag statement</a>,
Next:<a rel=next accesskey=n href="#IF%20tag%20statement">IF tag statement</a>,
Previous:<a rel=previous accesskey=p href="#Comments%20tag%20statement">Comments tag statement</a>,
Up:<a rel=up accesskey=u href="#Tag%20statements">Tag statements</a>
<br>

<h3>INCLUDE tag statement</h3>

<p>This tag is used to include another template file. This is useful if you
have the same header and/or footer in all your HTML pages. For example:

<br><pre>
@@INCLUDE@@ header.tmplt

&lt;P&gt;This is by Web page

@@INCLUDE@@ footer.tmplt
</pre>

<p>It is also possible to pass arguments to the include file. These parameters
are put after the include filename. It is possible to reference these
parameters into the included file with the special variable names
<code>@_$&lt;n&gt;_@</code>, where <i>n</i> is the include's parameter indice (0 is
the include filename, 1 the first parameter and so on).

<br><pre>
@@INCLUDE@@ another.tmplt @_VAR_@ azerty
</pre>

<p>In file <code>another.tmplt</code>

<dl>
<dt><code>@_$0_@</code>
<dd>is another.tmplt
<br><dt><code>@_$1_@</code>
<dd>is the variable @_VAR_@
<br><dt><code>@_$2_@</code>
<dd>is the string "azerty"
</dl>

<p>If an include variable references a non existing include parameter the
tag is kept as-is.

<p>Note that it is possible to pass the include parameters using names,
a set of positional parameters can be pass first, so all following
include command are identical:

<br><pre>
@@INCLUDE@@ another.tmplt one two three four "a text"
@@INCLUDE@@ another.tmplt (one, two, 3 =&gt; three, 4 =&gt; four, 5 =&gt; "a text")
@@INCLUDE@@ another.tmplt (one, 5 =&gt; "a text", 3 =&gt; three, 2 =&gt; two, 4 =&gt; four)
</pre>

<p><hr>
Node:<a name="IF%20tag%20statement">IF tag statement</a>,
Next:<a rel=next accesskey=n href="#TABLE%20tag%20statement">TABLE tag statement</a>,
Previous:<a rel=previous accesskey=p href="#INCLUDE%20tag%20statement">INCLUDE tag statement</a>,
Up:<a rel=up accesskey=u href="#Tag%20statements">Tag statements</a>
<br>

<h3>IF tag statement</h3>

<p>This is the conditional tag statement. The complete form is:

<br><pre>
@@IF@@ &lt;expression1&gt;
   part1
@@ELSIF@@ &lt;expression2&gt;
   part2
@@ELSE@@
   part3
@@END_IF@@
</pre>

<p>The part1 one will be parsed if expression1 evaluate to "TRUE", part2
will be parsed if expression2 evaluate to "TRUE" and the part3 will
be parse in any other case. The <code>ELSIF</code> and <code>ELSE</code> part are
optional.

<p>The expression here is composed of boolean variable (or conditional
variable) and/or boolean expression. Recognized operators are:

<dl>
<dt><code>A = B</code>
<dd>Returns TRUE if A equal B

<br><dt><code>A /= B</code>
<dd>Returns TRUE if A is not equal B

<br><dt><code>A &gt; B</code>
<dd>Returns TRUE if A greater than B. If A and B are numbers it returns the
the number comparison (5 &gt; 003 = TRUE) otherwise it returns the string
comparison ("5" &gt; "003" = FALSE).

<br><dt><code>A &gt;= B</code>
<dd>Returns TRUE if A greater than or equal to B. See above for rule about numbers.

<br><dt><code>A &lt; B</code>
<dd>Returns TRUE if A lesser than B. See above for rule about numbers.

<br><dt><code>A &lt;= B</code>
<dd>Returns TRUE if A lesser than or equal to B. See above for rule about numbers.

<br><dt><code>A and B</code>
<dd>Returns TRUE if A and B is TRUE and FALSE otherwise.

<br><dt><code>A or B</code>
<dd>Returns TRUE if A or B is TRUE and FALSE otherwise.

<br><dt><code>A xor B</code>
<dd>Returns TRUE if either A or B (but not both) is TRUE and FALSE otherwise.

<br><dt><code>not A</code>
<dd>Returns TRUE if either A is FALSE and FALSE otherwise. 
</dl>

<p>The default evaluation order is done from left to right, all operators
having the same precedence. To build an expression it is possible to
use the parentheses to change the evaluation order. A value with
spaces must be quoted as a string. So valid expressions could be:

<br><pre>
@@IF@@ (@_VAR1_@ &gt; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ not (@_VAR1_@ &gt; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ (@_VAR1_@ &gt; 3) and not @_COND1_@

@@IF@@ @_VAR1_@ = "a value"
</pre>

<p>Note also that variables and values can be surrounded by quotes if needed. 
Quotes are needed if a value contain spaces.

<p>To generate a conditional variable tag it is possible to use the
following <b>Templates_Parser</b> function:

<br><pre>
<p><b>function</b> Assoc (Variable  : <b>in</b> String;
                Value     : <b>in</b> Boolean;
                <b>return</b> Association;
<i>--  build an Association (Variable = Value) to be added to a</i>
<i>--  Translate_Table. It set the variable to TRUE or FALSE depending on</i>
<i>--  Value.</i>
</pre>

<p>Let's see an example using an <code>IF</code> tag statement. With the following
template:

<br><pre>

@@IF@@ @_USER_@
   &lt;P&gt;As a <b>use</b>r you have a restricted <b>access</b> to this server.
@@ELSE@@
   &lt;P&gt;As an administrator you have full <b>access</b> to this server.
@@END_IF@@
</pre>

<p>The following program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> User1 <b>is</b>

   Translations : <b>constant</b> Templates_Parser.Translate_Table
     := (1 =&gt; Templates_Parser.Assoc ("<i>USER</i>", True));

<b>begin</b>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>user.tmplt</i>", Translations));
<b>end</b> User1;
</pre>

<p>Will display:

<br><pre>
&lt;P&gt;As a user you have a restricted access to this server.
</pre>

<p>But the following program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> User2 <b>is</b>

   Translations : <b>constant</b> Templates_Parser.Translate_Table
     := (1 =&gt; Templates_Parser.Assoc ("<i>USER</i>", False));

<b>begin</b>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>user.tmplt</i>", Translations));
<b>end</b> User2;
</pre>

<p>Will display:

<br><pre>
&lt;P&gt;As an administrator you have full access to this server.
</pre>

<p><hr>
Node:<a name="TABLE%20tag%20statement">TABLE tag statement</a>,
Next:<a rel=next accesskey=n href="#SET%20tag%20statement">SET tag statement</a>,
Previous:<a rel=previous accesskey=p href="#IF%20tag%20statement">IF tag statement</a>,
Up:<a rel=up accesskey=u href="#Tag%20statements">Tag statements</a>
<br>

<h3>TABLE tag statement</h3>

<p>A table tag is useful to generate <code>HTML</code> table for example. Basically the
code between the <code>@@TABLE@@</code> and <code>@@END_TABLE@@</code> will
be repeated as many time as the vector tag will have of values. If many
vector tags are specified in a table statement, the code between the
table will be repeated a number of time equal to the maximum length of
all vector tags in the <code>TABLE</code> tag statement.

<p>A <code>TABLE</code> tag statement is a kind of implicit iterator. This is a very
important concept to build HTML tables. Using a composite tag variable in
a <code>@@TABLE@@</code> tag statement it is possible to build very
complex Web pages.

<p>Syntax:

<br><pre>
@@TABLE@@ [@@TERMINATE_SECTIONS@@]
      ...
   [@@BEGIN@@]
      ...
   [@@SECTION@@]
      ...
   [@@END@@]
      ...
@@END_TABLE@@
</pre>

<p>Let's have an example. With the following template:

<br><pre>


&lt;P&gt;Here <b>is</b> the ages <b>of</b> some peoples:

&lt;TABLE&gt;
@@TABLE@@
   &lt;TR&gt;
   &lt;TD&gt;@_NAME_@
   &lt;TD&gt;@_AGE_@
@@END_TABLE@@
&lt;/TABLE&gt;
</pre>

<p>And the following program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> Table <b>is</b>

   <b>use</b> <b>type</b> Templates_Parser.Vector_Tag;

   Names : <b>constant</b> Templates_Parser.Vector_Tag
     := +"<i>Bob</i>" &amp; "<i>Bill</i>" &amp; "<i>Toto</i>";
   Ages  : <b>constant</b> Templates_Parser.Vector_Tag
     := +"<i>10</i>" &amp; "<i>30</i>" &amp; "<i>5</i>";

   Translations : <b>constant</b> Templates_Parser.Translate_Table
     := (1 =&gt; Templates_Parser.Assoc ("<i>NAME</i>", Names),
         2 =&gt; Templates_Parser.Assoc ("<i>AGE</i>", Ages));

<b>begin</b>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>table.tmplt</i>", Translations));
<b>end</b> Table;
</pre>

<p>The following output will be generated:

<br><pre>

&lt;P&gt;Here is the ages of some peoples:

&lt;TABLE&gt;
   &lt;TR&gt;
   &lt;TD&gt;Bob
   &lt;TD&gt;10
   &lt;TR&gt;
   &lt;TD&gt;Bill
   &lt;TD&gt;30
   &lt;TR&gt;
   &lt;TD&gt;Toto
   &lt;TD&gt;5
&lt;/TABLE&gt;
</pre>

<p>Note that we use vector tag variables here. A discrete variable tag in a table
will be replaced by the same (the only one) value for each row. A vector
tag outside a table will be displayed as a list of values, each value
being separated by a specified separator. The default is a comma and a
space ", ".

<p>The complete prototype for the <code>Tag</code> Assoc function is:

<br><pre>
<p><b>function</b> Assoc (Variable  : <b>in</b> String;
                Value     : <b>in</b> Tag;
                Separator : <b>in</b> String    := Default_Separator;
                <b>return</b> Association;
<i>--  Build an Association (Variable = Value) to be added to Translate_Table.</i>
<i>--  This is a tag association. Separator will be used when outputting the</i>
<i>--  a flat representation of the Tag (outside a table statement).</i>
</pre>

<p>A table can contain many sections. The section to use will be selected
depending on the current line. For example, a table with two sections
will use different data on even and odd lines. This is useful when you
want to alternate the line background color for a better readability
when working on HTML pages.

<p>A table with sections can have the modifier
<code>@@TERMINATE_SECTIONS@@</code>. This ensure that the table output will end
with the last section. If the number of data in the vector variable tag
is not a multiple of the number of sections then the remaining section
will be complete with empty tag value.

<br><pre>


&lt;P&gt;Here are some available computer devices:

&lt;TABLE&gt;
@@TABLE@@
   &lt;TR BGCOLOR=#FF0000&gt;
   &lt;TD&gt;@_DEVICES_@
   &lt;TD&gt;@_PRICES_@
@@SECTION@@
   &lt;TR BGCOLOR=#00000F&gt;
   &lt;TD&gt;@_DEVICES_@
   &lt;TD&gt;@_PRICES_@
@@END_TABLE@@
&lt;/TABLE&gt;

&lt;TABLE&gt;
@@TABLE@@ @@TERMINATE_SECTIONS@@
   &lt;TR&gt;
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
   &lt;TD WIDTH=150&gt;@_DEVICES_@
@@SECTION@@
   &lt;TD WIDTH=150&gt;@_DEVICES_@
@@SECTION@@
   &lt;TD WIDTH=150&gt;@_DEVICES_@
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
@@END_TABLE@@
&lt;/TABLE&gt;
</pre>

<p>And the following program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> Table_Section <b>is</b>

   <b>use</b> <b>type</b> Templates_Parser.Vector_Tag;

   Devices : <b>constant</b> Templates_Parser.Vector_Tag
     := +"<i>Screen</i>" &amp; "<i>Keyboard</i>" &amp; "<i>Mouse</i>" &amp; "<i>Hard Drive</i>";
   Prices  : <b>constant</b> Templates_Parser.Vector_Tag
     := +"<i>$500</i>" &amp; "<i>$20</i>" &amp; "<i>$15</i>" &amp; "<i>$140</i>";

   Translations : <b>constant</b> Templates_Parser.Translate_Table
     := (1 =&gt; Templates_Parser.Assoc ("<i>DEVICES</i>", Devices),
         2 =&gt; Templates_Parser.Assoc ("<i>PRICES</i>", Prices));

<b>begin</b>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>table_section.tmplt</i>", Translations));
<b>end</b> Table_Section;
</pre>

<p>The following output will be generated:

<br><pre>

&lt;P&gt;Here are some available computer devices:

&lt;TABLE&gt;
   &lt;TR BGCOLOR=#FF0000&gt;
   &lt;TD&gt;Screen
   &lt;TD&gt;$500
   &lt;TR BGCOLOR=#00000F&gt;
   &lt;TD&gt;Keyboard
   &lt;TD&gt;$20
   &lt;TR BGCOLOR=#FF0000&gt;
   &lt;TD&gt;Mouse
   &lt;TD&gt;$15
   &lt;TR BGCOLOR=#00000F&gt;
   &lt;TD&gt;Hard Drive
   &lt;TD&gt;$140
&lt;/TABLE&gt;

&lt;TABLE&gt;
   &lt;TR&gt;
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
   &lt;TD WIDTH=150&gt;Screen
   &lt;TD WIDTH=150&gt;Keyboard
   &lt;TD WIDTH=150&gt;Mouse
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
   &lt;TR&gt;
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
   &lt;TD WIDTH=150&gt;Hard Drive
   &lt;TD WIDTH=150&gt;
   &lt;TD WIDTH=150&gt;
   &lt;TD BGCOLOR=#00000F WIDTH=10&gt;
&lt;/TABLE&gt;
</pre>

<p>It is important to note that is is possible to avoid code
duplication by using the <code>@@BEGIN@@</code> and <code>@@END@@</code>
block statements. In this case only the code inside the block is part
of the section, code outside is common text to all sections. Here is
an example to generate an HTML table with different colors for each line:

<p>The template file above can be written this way:

<br><pre>


&lt;P&gt;Here are some available computer devices:

&lt;TABLE&gt;
@@TABLE@@
   &lt;TR BGCOLOR=
   @@BEGIN@@
      "<i>#FF0000</i>"
   @@SECTION@@
      "<i>#000000F</i>"
   @@END@@
   &gt;
   &lt;TD&gt;@_DEVICES_@
   &lt;TD&gt;@_PRICES_@
@@END_TABLE@@
&lt;/TABLE&gt;
</pre>

<p>Into a table construct there are some additional variable tags available:

<dl>
<dt><code>@_UP_TABLE_LINE_@</code>
<dd>

<p>This tag will be replaced by the table line number of the upper table
statement. It will be set to 0 outside a table statement or inside a
single table statement.

<br><dt><code>@_TABLE_LINE_@</code>
<dd>

<p>This tag will be replaced by the current table line number. It will be
replaced by 0 outside a table statement.

<br><dt><code>@_NUMBER_LINE_@</code>
<dd>

<p>This is the number of line displayed in the table. It will be replaced
by 0 outside a table statement.

<br><dt><code>@_TABLE_LEVEL_@</code>
<dd>

<p>This is the table level number. A table construct declared in a table
has a level value of 2.  It will be replaced by 0 outside a table statement.

</dl>

<p>Let's have a look at a more complex example with mixed IF and TABLE tag
statement.

<p>Here is the template:

<br><pre>


Hello here are a list <b>of</b> devices:

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Device Name
&lt;th&gt;Price
&lt;th&gt;Order

@@TABLE@@
&lt;tr&gt;
&lt;td&gt;@_DEVICES_@
&lt;td&gt;@_PRICES_@

&lt;td&gt;
@@IF@@ @_AVAILABLE_@
&lt;a href="<i>/order?DEVICE=@_DEVICES_@</i>"&gt;Order
@@ELSE@@
Sorry, not available
@@END_IF@@

@@END_TABLE@@
</pre>

<p>And the following program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> Table_If <b>is</b>

   <b>use</b> <b>type</b> Templates_Parser.Vector_Tag;

   <b>function</b> In_Stock (Device : <b>in</b> String) <b>return</b> Boolean;
   -- <i> Complex function. Does a SQL access to the right database to know if</i>
   -- <i> the Device is available and thus can be ordered.</i>

   <b>procedure</b> Add (Device, Price : <b>in</b> String);
   -- <i> Add the device into the list to be displayed.</i>

   Devices   : Templates_Parser.Tag;
   Prices    : Templates_Parser.Tag;
   Available : Templates_Parser.Tag;

   ---------
   -- <i>Add --</i>
   ---------

   <b>procedure</b> Add (Device, Price : <b>in</b> String) <b>is</b>
   <b>begin</b>
      Devices   := Devices &amp; Device;
      Prices    := Prices &amp; Price;
      Available := Available &amp; In_Stock (Device);
   <b>end</b> Add;

   --------------
   -- <i>In_Stock --</i>
   --------------

   <b>function</b> In_Stock (Device : <b>in</b> String) <b>return</b> Boolean <b>is</b>
   <b>begin</b>
      <b>if</b> Device = "<i>Keyboard</i>" <b>then</b>
         <b>return</b> True;
      <b>else</b>
         <b>return</b> False;
      <b>end</b> <b>if</b>;
   <b>end</b> In_Stock;

   Translations : Templates_Parser.Translate_Table (1 .. 3);

<b>begin</b>
   Add ("<i>Screen</i>", "<i>$500</i>");
   Add ("<i>Keyboard</i>", "<i>$15</i>");
   Add ("<i>Mouse</i>", "<i>$15</i>");
   Add ("<i>Hard Drive</i>", "<i>$140</i>");

   Translations := (Templates_Parser.Assoc ("<i>DEVICES</i>", Devices),
                    Templates_Parser.Assoc ("<i>PRICES</i>", Prices),
                    Templates_Parser.Assoc ("<i>AVAILABLE</i>", Available));

   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<i>table_if.tmplt</i>", Translations));
<b>end</b> Table_If;
</pre>

<p>The following output will be generated:

<br><pre>

Hello here are a list of devices:

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Device Name
&lt;th&gt;Price
&lt;th&gt;Order

&lt;tr&gt;
&lt;td&gt;Screen
&lt;td&gt;$500

&lt;td&gt;
Sorry, not available

&lt;tr&gt;
&lt;td&gt;Keyboard
&lt;td&gt;$15

&lt;td&gt;
&lt;a href="/order?DEVICE=Keyboard"&gt;Order

&lt;tr&gt;
&lt;td&gt;Mouse
&lt;td&gt;$15

&lt;td&gt;
Sorry, not available

&lt;tr&gt;
&lt;td&gt;Hard Drive
&lt;td&gt;$140

&lt;td&gt;
Sorry, not available
</pre>

<p>Table tag statements can also be used with matrix tag or more nested
tag variables. In this case, for a tag variable with N nested level,
the Nth closest enclosing <code>TABLE</code> tag statement will be used for
the corresponding indices. If there is not enough indices, the last
axis are just streamed as a single text value.

<p>Let's see what happen for a matrix tag:

<ol type=1 start=1>

</p><li>Inside a table of level 2 (a TABLE tag statement inside a TABLE tag
statement).

<p>In this case the first <code>TABLE</code> iterates through the matrix lines. 
First iteration will use the first matrix's vector, second
iteration will use second matrix's vector and so on. And the second
<code>TABLE</code> will be use to iterate through the vector's values.

</p><li>Inside a table of level 1.

<p>In this case the <code>TABLE</code> iterates through the matrix lines. First
iteration will use the first matrix's vector, second iteration will
use second matrix's vector and so on. Each vector is then converted to
a string by concatenating all values using the specified separator
(see Assoc constructor for Tag or <code>Set_Separator</code> routine).

</p><li>Outside a table statement.

<p>In this case the matrix is converted to a string. Each line represents
a vector converted as a string using the supplied separator (see point
2 above), and each vector is separated by an ASCII.LF character. The
separators to use for each level can be specified using <code>Set_Separator</code>.

</ol>

<p>Let's look at an example, with the following template:

<br><pre>


A matrix <b>in</b>side a table <b>of</b> level 2:

@@TABLE@@
&lt;tr&gt;
@@TABLE@@
&lt;td&gt;
@_MAT_@
&lt;/td&gt;
@@END_TABLE@@
&lt;/tr&gt;

@@END_TABLE@@

The same matrix <b>in</b>side a single table:

@@TABLE@@
&lt;tr&gt;
&lt;td&gt;
@_MAT_@
&lt;/tr&gt;

@@END_TABLE@@

The same matrix <b>out</b>side a table:

@_MAT_@
</pre>

<p>Using the program:

<br><pre>


<p><b>with</b> Ada.Text_IO;
<b>with</b> Templates_Parser;

<b>procedure</b> Matrix <b>is</b>

   <b>package</b> TP renames Templates_Parser;

   <b>use</b> <b>type</b> TP.Vector_Tag;
   <b>use</b> <b>type</b> TP.Matrix_Tag;

   V1 : <b>constant</b> TP.Vector_Tag := +"<i>A1.1</i>" &amp; "<i>A1.2</i>";
   V2 : <b>constant</b> TP.Vector_Tag := +"<i>A2.1</i>" &amp; "<i>A2.2</i>";
   V3 : <b>constant</b> TP.Vector_Tag := +"<i>A3.1</i>" &amp; "<i>A3.2</i>";

   M  : <b>constant</b> TP.Matrix_Tag := +V1 &amp; V2 &amp; V3;

<b>begin</b>
   Ada.Text_IO.Put_Line
     (TP.Parse ("<i>matrix.tmplt</i>",
                TP.Translate_Table'(1 =&gt; TP.Assoc ("<i>MAT</i>", M))));
<b>end</b> Matrix;
</pre>

<p>We get the following result:

<br><pre>

A matrix inside a table of level 2:

&lt;tr&gt;
&lt;td&gt;
A1.1
&lt;/td&gt;
&lt;td&gt;
A1.2
&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
A2.1
&lt;/td&gt;
&lt;td&gt;
A2.2
&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
A3.1
&lt;/td&gt;
&lt;td&gt;
A3.2
&lt;/td&gt;
&lt;/tr&gt;


The same matrix inside a single table:

&lt;tr&gt;
&lt;td&gt;
A1.1, A1.2
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
A2.1, A2.2
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
A3.1, A3.2
&lt;/tr&gt;


The same matrix outside a table:

A1.1, A1.2
A2.1, A2.2
A3.1, A3.2
</pre>

<p><hr>
Node:<a name="SET%20tag%20statement">SET tag statement</a>,
Previous:<a rel=previous accesskey=p href="#TABLE%20tag%20statement">TABLE tag statement</a>,
Up:<a rel=up accesskey=u href="#Tag%20statements">Tag statements</a>
<br>

<h3>SET tag statement</h3>

<p>The <code>SET</code> command tag can be used to define a constant or an
alias for an include file parameter. This is especially important in
the context of reusable template files. For example, instead of having
many references to the <b>red</b> color in an HTML document, it is better to
define a constant <var>COLOR</var> with the value <b>red</b> and use <var>COLOR</var>
everywhere. It is then easier to change the color afterward.

<p>The first form, to define a simple constant that can be used as any
other variable in a template file, is:

<br><pre>
@@SET@@ &lt;name&gt; = &lt;value&gt;
</pre>

<p>The second form, to define an alias for a template file parameter, is:

<br><pre>
@@SET@@ &lt;name&gt; = $n [| &lt;default_value&gt;]
</pre>

<p>In this case &lt;name&gt; is an alias for the Nth include parameter. In this
form it is also possible to define a default value that would be used
if the Nth include parameter is not specified.

<p>Some examples:

<br><pre>
@@SET@@ COLOR = red

@@SET@@ SIZE = $1

@@SET@@ COLOR = $4 | green
</pre>

<p><hr>
Node:<a name="Other%20services">Other services</a>,
Next:<a rel=next accesskey=n href="#Last%20notes">Last notes</a>,
Previous:<a rel=previous accesskey=p href="#Tag%20statements">Tag statements</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Other services</h2>

<ul>
<li><a accesskey=1 href="#Context">Context</a>: 
<li><a accesskey=2 href="#Tag%20utils">Tag utils</a>: 
<li><a accesskey=3 href="#XML%20representation">XML representation</a>: 
<li><a accesskey=4 href="#Debug">Debug</a>: 
</ul>

<p><hr>
Node:<a name="Context">Context</a>,
Next:<a rel=next accesskey=n href="#Tag%20utils">Tag utils</a>,
Up:<a rel=up accesskey=u href="#Other%20services">Other services</a>
<br>

<h3>Context</h3>

<p>The context object can be used to dynamically handle tags. Such
context can be passed to the <code>Parse</code> routines. If a template's tag
is not found in the <code>Translate_Table</code> the context callback method
is called by the parser. The default callback method does nothing, it
is up to the user to define it. The callback procedure is defined as
follow:

<br><pre>
<p><b>procedure</b> Callback
  (Context  : <b>access</b> Templates_Parser.Context;
   Variable : <b>in</b>     String;
   Result   :    <b>out</b> Unbounded_String;
   Found    :    <b>out</b> Boolean);
</pre>

<p><code>Result</code> must be set with the value for the tag <code>Variable</code>
and <code>Found</code> set to <code>True</code>, otherwise <code>Found</code> can be set
to <code>False</code>.

<p><hr>
Node:<a name="Tag%20utils">Tag utils</a>,
Next:<a rel=next accesskey=n href="#XML%20representation">XML representation</a>,
Previous:<a rel=previous accesskey=p href="#Context">Context</a>,
Up:<a rel=up accesskey=u href="#Other%20services">Other services</a>
<br>

<h3>Tag utils</h3>

<p>The child package <code>Utils</code>, see <a href="#Templates_Parser.Utils">Templates_Parser.Utils</a>
contains a routine to encode a Tag variable into a string and the
inverse routine that build a Tag given it's string
representation. This is usefuln for example, in the context of AWS to
store a Tag into a session variable. See AWS project.

<p><hr>
Node:<a name="XML%20representation">XML representation</a>,
Next:<a rel=next accesskey=n href="#Debug">Debug</a>,
Previous:<a rel=previous accesskey=p href="#Tag%20utils">Tag utils</a>,
Up:<a rel=up accesskey=u href="#Other%20services">Other services</a>
<br>

<h3>XML representation</h3>

<p>The child package <code>XML</code>, see <a href="#Templates_Parser.XML">Templates_Parser.XML</a> contains
routines to save a <code>Translation_Set</code> into an XML document or to
create a <code>Translation_Set</code> by loading an XML document. The XML
document must conforms to a specific <code>DTD</code> (see Ada spec file).

<p><hr>
Node:<a name="Debug">Debug</a>,
Previous:<a rel=previous accesskey=p href="#XML%20representation">XML representation</a>,
Up:<a rel=up accesskey=u href="#Other%20services">Other services</a>
<br>

<h3>Debug</h3>

<p>A set of routine to help debug the <code>Templates_Parser</code> engine,
see <a href="#Templates_Parser.Debug">Templates_Parser.Debug</a>. For example, <code>Debug.Print_Tree</code>
will display, to the standard output, a representation of the internal
semantic tree for a template file.

<p><hr>
Node:<a name="Last%20notes">Last notes</a>,
Next:<a rel=next accesskey=n href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>,
Previous:<a rel=previous accesskey=p href="#Other%20services">Other services</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Last notes</h2>

<p>The templates parser has be written to parse <code>HTML</code> page but it is usable
with any king of files. There is nothing hard coded for <code>HTML</code>, it is then
possible to use it with plain text files, <code>XML</code> files, <code>SGML</code> files
or whatever as long as it is not a binary file.

<br><p>
<br><p>
<p>All tag statements can be mixed together. A <code>TABLE</code> tag statement can be
put in an <code>IF</code> tag statement. An <code>IF</code> tag statement can be put
in a <code>TABLE</code> tag statement. Idem for the <code>INCLUDE</code> tag statement.

<p>Download page is &lt;<code>http://www.obry.org/</code>&gt;.

<br><p>
<br><p>
<br><p>
<p><hr>
Node:<a name="Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>,
Next:<a rel=next accesskey=n href="#Index">Index</a>,
Previous:<a rel=previous accesskey=p href="#Last%20notes">Last notes</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Templates_Parser API Reference</h2>

<p>Templates_Parser User's API

<ul>
<li><a accesskey=1 href="#Templates_Parser">Templates_Parser</a>: 
<li><a accesskey=2 href="#Templates_Parser.Debug">Templates_Parser.Debug</a>: 
<li><a accesskey=3 href="#Templates_Parser.Utils">Templates_Parser.Utils</a>: 
<li><a accesskey=4 href="#Templates_Parser.XML">Templates_Parser.XML</a>: 
</ul>

<p><hr>
Node:<a name="Templates_Parser">Templates_Parser</a>,
Next:<a rel=next accesskey=n href="#Templates_Parser.Debug">Templates_Parser.Debug</a>,
Up:<a rel=up accesskey=u href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>
<br>

<h3>Templates_Parser</h3>

<br><pre>
------------------------------------------------------------------------------
-- <i>                            Templates Parser                             --</i>
-- <i>                                                                         --</i>
-- <i>                       Copyright (C) 1999 - 2004                         --</i>
-- <i>                              Pascal Obry                                --</i>
-- <i>                                                                         --</i>
-- <i> This library is free software; you can redistribute it and/or modify    --</i>
-- <i> it under the terms of the GNU General Public License as published by    --</i>
-- <i> the Free Software Foundation; either version 2 of the License, or (at   --</i>
-- <i> your option) any later version.                                         --</i>
-- <i>                                                                         --</i>
-- <i> This library is distributed in the hope that it will be useful, but     --</i>
-- <i> WITHOUT ANY WARRANTY; without even the implied warranty of              --</i>
-- <i> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</i>
-- <i> General Public License for more details.                                --</i>
-- <i>                                                                         --</i>
-- <i> You should have received a copy of the GNU General Public License       --</i>
-- <i> along with this library; if not, write to the Free Software Foundation, --</i>
-- <i> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</i>
-- <i>                                                                         --</i>
-- <i> As a special exception, if other files instantiate generics from this   --</i>
-- <i> unit, or you link this unit with other files to produce an executable,  --</i>
-- <i> this  unit  does not  by itself cause  the resulting executable to be   --</i>
-- <i> covered by the GNU General Public License. This exception does not      --</i>
-- <i> however invalidate any other reasons why the executable file  might be  --</i>
-- <i> covered by the  GNU Public License.                                     --</i>
------------------------------------------------------------------------------

-- <i> $Id$</i>

<b>with</b> Ada.Finalization;
<b>with</b> Ada.Strings.Unbounded;

<b>with</b> Strings_Maps;

<b>package</b> Templates_Parser <b>is</b>

   <b>use</b> Ada.Strings.Unbounded;

   Template_Error : <b>exception</b>;

   Default_Begin_Tag : <b>constant</b> String := "<i>@_</i>";
   Default_End_Tag   : <b>constant</b> String := "<i>_@</i>";

   Default_Separator : <b>constant</b> String := "<i>, </i>";

   <b>procedure</b> Set_Tag_Separators
     (Start_With : <b>in</b> String := Default_Begin_Tag;
      Stop_With  : <b>in</b> String := Default_End_Tag);
   -- <i> Set the tag separators for the whole session. This should be changed as</i>
   -- <i> the very first API call and should not be changed after.</i>

   -----------------
   -- <i>Generic Tag --</i>
   -----------------

   <b>type</b> Tag <b>is</b> <b>private</b>;
   -- <i> A tag is using a by reference semantic</i>

   <b>function</b> "<i>+</i>" (Value : <b>in</b> String)           <b>return</b> Tag;
   <b>function</b> "<i>+</i>" (Value : <b>in</b> Character)        <b>return</b> Tag;
   <b>function</b> "<i>+</i>" (Value : <b>in</b> Boolean)          <b>return</b> Tag;
   <b>function</b> "<i>+</i>" (Value : <b>in</b> Unbounded_String) <b>return</b> Tag;
   <b>function</b> "<i>+</i>" (Value : <b>in</b> Integer)          <b>return</b> Tag;
   <b>function</b> "<i>+</i>" (Value : <b>in</b> Tag)              <b>return</b> Tag;
   -- <i> Tag constructors</i>

   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> String)           <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> Character)        <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> Boolean)          <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> Unbounded_String) <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> Integer)          <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (T : <b>in</b> Tag; Value : <b>in</b> Tag)              <b>return</b> Tag;
   -- <i> Add Value at the end of the tag</i>

   <b>function</b> "<i>&amp;</i>" (Value : <b>in</b> String;           T : <b>in</b> Tag) <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (Value : <b>in</b> Character;        T : <b>in</b> Tag) <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (Value : <b>in</b> Boolean;          T : <b>in</b> Tag) <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (Value : <b>in</b> Unbounded_String; T : <b>in</b> Tag) <b>return</b> Tag;
   <b>function</b> "<i>&amp;</i>" (Value : <b>in</b> Integer;          T : <b>in</b> Tag) <b>return</b> Tag;
   -- <i> Add Value at the front of the tag</i>

   <b>procedure</b> Set_Separator (T : <b>in</b> <b>out</b> Tag; Separator : <b>in</b> String);
   -- <i> Set separator to be used when building a flat representation of</i>
   -- <i> a composite tag.</i>

   <b>procedure</b> Clear (T : <b>in</b> <b>out</b> Tag);
   -- <i> Removes all values in the tag. Current tag T is not released but</i>
   -- <i> the returned object is separated (not using the same reference) than</i>
   -- <i> the original one.</i>

   <b>function</b> Size (T : <b>in</b> Tag) <b>return</b> Natural;
   -- <i> Returns the number of value into T</i>

   <b>function</b> Item (T : <b>in</b> Tag; N : <b>in</b> Positive) <b>return</b> String;
   -- <i> Returns the Nth Tag's item. Raises Constraint_Error if there is</i>
   -- <i> no such Item in T (i.e. T length &lt; N).</i>

   <b>function</b> Composite (T : <b>in</b> Tag; N : <b>in</b> Positive) <b>return</b> Tag;
   -- <i> Returns the Nth Tag's item. Raises Constraint_Error if there is</i>
   -- <i> no such Item in T (i.e. T length &lt; N).</i>

   <b>subtype</b> Vector_Tag <b>is</b> Tag;
   <b>subtype</b> Matrix_Tag <b>is</b> Tag;

   ------------------
   -- <i>Associations --</i>
   ------------------

   <b>type</b> Association <b>is</b> <b>private</b>;

   Null_Association : <b>constant</b> Association;

   <b>type</b> Association_Kind <b>is</b> (Std, Composite);
   -- <i> The kind of association which is either Std (a simple value), a vector</i>
   -- <i> tag or a Matrix tag.</i>

   <b>function</b> Assoc
     (Variable : <b>in</b> String;
      Value    : <b>in</b> String)
      <b>return</b> Association;
   -- <i> Build an Association (Variable = Value) to be added to a</i>
   -- <i> Translate_Table. This is a standard association, value is a string.</i>

   <b>function</b> Assoc
     (Variable : <b>in</b> String;
      Value    : <b>in</b> Unbounded_String)
      <b>return</b> Association;
   -- <i> Build an Association (Variable = Value) to be added to a</i>
   -- <i> Translate_Table. This is a standard association, value is an</i>
   -- <i> Unbounded_String.</i>

   <b>function</b> Assoc
     (Variable : <b>in</b> String;
      Value    : <b>in</b> Integer)
      <b>return</b> Association;
   -- <i> Build an Association (Variable = Value) to be added to a</i>
   -- <i> Translate_Table. This is a standard association, value is an Integer.</i>
   -- <i> It will be displayed without leading space if positive.</i>

   <b>function</b> Assoc
     (Variable : <b>in</b> String;
      Value    : <b>in</b> Boolean)
      <b>return</b> Association;
   -- <i> Build an Association (Variable = Value) to be added to a</i>
   -- <i> Translate_Table. It set the variable to TRUE or FALSE depending on</i>
   -- <i> value.</i>

   <b>function</b> Assoc
     (Variable  : <b>in</b> String;
      Value     : <b>in</b> Tag;
      Separator : <b>in</b> String := Default_Separator)
      <b>return</b> Association;
   -- <i> Build an Association (Variable = Value) to be added to Translate_Table.</i>
   -- <i> This is a tag association. Separator will be used when outputting the</i>
   -- <i> a flat representation of the Tag (outside a table statement).</i>

   <b>function</b> Get (Assoc : <b>in</b> Association) <b>return</b> Tag;
   -- <i> Returns the Tag in Assoc, raise Constraint_Error if Assoc is not</i>
   -- <i> containing a Tag (Association_Kind is Std).</i>

   ---------------------------
   -- <i>Association table/set --</i>
   ---------------------------

   <b>type</b> Translate_Table <b>is</b> <b>array</b> (Positive <b>range</b> &lt;&gt;) <b>of</b> Association;
   -- <i> A table with a set of associations, note that it is better to use</i>
   -- <i> Translate_Set below as it is more efficient.</i>

   No_Translation : <b>constant</b> Translate_Table;

   <b>type</b> Translate_Set <b>is</b> <b>private</b>;
   -- <i> This is a set of association like Translate_Table but it is possible to</i>
   -- <i> insert item into this set more easily, furthermore there is no need to</i>
   -- <i> know the number of item before hand. This is the object used internally</i>
   -- <i> by the templates engine as it is far more efficient to retrieve a</i>
   -- <i> specific item from it.</i>

   <b>procedure</b> Insert (Set : <b>in</b> <b>out</b> Translate_Set; Item : <b>in</b> Association);
   -- <i> Add Item into the translate set. If an association for this variable</i>
   -- <i> already exists it just replaces it by the new item.</i>

   <b>procedure</b> Insert (Set : <b>in</b> <b>out</b> Translate_Set; Items : <b>in</b> Translate_Set);
   -- <i> Add Items into the translate set. If an association for variables in</i>
   -- <i> Items already exists it just replaces it by the new one.</i>

   <b>procedure</b> Remove (Set : <b>in</b> <b>out</b> Translate_Set; Name : <b>in</b> String);
   -- <i> Removes association named Name from the Set. Does nothing if there is</i>
   -- <i> not such association in the set.</i>

   <b>function</b> Get (Set : <b>in</b> Translate_Set; Name : <b>in</b> String) <b>return</b> Association;
   -- <i> Returns the association named Name in the Set. Returns Null_Association</i>
   -- <i> is no such association if found in Set.</i>

   <b>function</b> Exists
     (Set      : <b>in</b> Translate_Set;
      Variable : <b>in</b> String) <b>return</b> Boolean;
   -- <i> Returns True if an association for Variable exists into the Set</i>

   generic
      <b>with</b> <b>procedure</b> Action
        (Item : <b>in</b>     Association;
         Quit : <b>in</b> <b>out</b> Boolean);
   <b>procedure</b> For_Every_Association (Set : <b>in</b> Translate_Set);
   -- <i> Iterates through all associations in the set, call Action for each one.</i>
   -- <i> Set Quite to True to stop the iteration.</i>

   <b>function</b> To_Set (Table : <b>in</b> Translate_Table) <b>return</b> Translate_Set;
   -- <i> Convert a Translate_Table into a Translate_Set</i>

   ---------------
   -- <i>Callbacks --</i>
   ---------------

   <b>type</b> Context <b>is</b> tagged <b>private</b>;
   <b>type</b> Context_Access <b>is</b> <b>access</b> all Context'Class;

   <b>procedure</b> Callback
     (Context  : <b>access</b> Templates_Parser.Context;
      Variable : <b>in</b>     String;
      Result   :    <b>out</b> Unbounded_String;
      Found    :    <b>out</b> Boolean);
   -- <i> Callback is called by the Parse routines below if a tag variable was not</i>
   -- <i> found in the set of translations. This routine must then set Result with</i>
   -- <i> the value to use for Variable (name of the variable tag) and in this</i>
   -- <i> case Found must be set to True. If Variable is not handled in this</i>
   -- <i> callback, Found must be set to False. This default implementation will</i>
   -- <i> always return with Found set to False.</i>

   Null_Context : <b>constant</b> Context_Access;

   -----------------------------
   -- <i>Parsing and Translating --</i>
   -----------------------------

   <b>function</b> Parse
     (Filename          : <b>in</b> String;
      Translations      : <b>in</b> Translate_Table := No_Translation;
      Cached            : <b>in</b> Boolean         := False;
      Keep_Unknown_Tags : <b>in</b> Boolean         := False;
      Context           : <b>in</b> Context_Access  := Null_Context)
      <b>return</b> String;
   -- <i> Parse the Template_File replacing variables' occurrences by the</i>
   -- <i> corresponding values. If Cached is set to True, Filename tree will be</i>
   -- <i> recorded into a cache for quick retrieval. If Keep_Unknown_Tags is set</i>
   -- <i> to True then tags that are not in the translate table are kept</i>
   -- <i> as-is if it is part of the template data. If this tags is part of a</i>
   -- <i> condition (in an IF statement tag), the condition will evaluate to</i>
   -- <i> False.</i>

   <b>function</b> Parse
     (Filename          : <b>in</b> String;
      Translations      : <b>in</b> Translate_Table := No_Translation;
      Cached            : <b>in</b> Boolean         := False;
      Keep_Unknown_Tags : <b>in</b> Boolean         := False;
      Context           : <b>in</b> Context_Access  := Null_Context)
      <b>return</b> Unbounded_String;
   -- <i> Idem but returns an Unbounded_String</i>

   <b>function</b> Parse
     (Filename          : <b>in</b> String;
      Translations      : <b>in</b> Translate_Set;
      Cached            : <b>in</b> Boolean        := False;
      Keep_Unknown_Tags : <b>in</b> Boolean        := False;
      Context           : <b>in</b> Context_Access := Null_Context)
      <b>return</b> String;
   -- <i> Idem with a Translation_Set</i>

   <b>function</b> Parse
     (Filename          : <b>in</b> String;
      Translations      : <b>in</b> Translate_Set;
      Cached            : <b>in</b> Boolean        := False;
      Keep_Unknown_Tags : <b>in</b> Boolean        := False;
      Context           : <b>in</b> Context_Access := Null_Context)
      <b>return</b> Unbounded_String;
   -- <i> Idem with a Translation_Set</i>

   <b>function</b> Translate
     (Template     : <b>in</b> String;
      Translations : <b>in</b> Translate_Table := No_Translation)
      <b>return</b> String;
   -- <i> Just translate the discrete variables in the Template string using the</i>
   -- <i> Translations table. This function does not parse the command tag (TABLE,</i>
   -- <i> IF, INCLUDE). All composite tags are replaced by the empty string.</i>

   <b>function</b> Translate
     (Template     : <b>in</b> String;
      Translations : <b>in</b> Translate_Set)
      <b>return</b> String;
   -- <i> Idem with a Translation_Set</i>

<b>private</b>
   -- <i> implementation removed</i>
<b>end</b> Templates_Parser;

</pre>

<p><hr>
Node:<a name="Templates_Parser.Debug">Templates_Parser.Debug</a>,
Next:<a rel=next accesskey=n href="#Templates_Parser.Utils">Templates_Parser.Utils</a>,
Previous:<a rel=previous accesskey=p href="#Templates_Parser">Templates_Parser</a>,
Up:<a rel=up accesskey=u href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>
<br>

<h3>Templates_Parser.Debug</h3>

<br><pre>
------------------------------------------------------------------------------
-- <i>                            Templates Parser                             --</i>
-- <i>                                                                         --</i>
-- <i>                           Copyright (C) 2004                            --</i>
-- <i>                              Pascal Obry                                --</i>
-- <i>                                                                         --</i>
-- <i> This library is free software; you can redistribute it and/or modify    --</i>
-- <i> it under the terms of the GNU General Public License as published by    --</i>
-- <i> the Free Software Foundation; either version 2 of the License, or (at   --</i>
-- <i> your option) any later version.                                         --</i>
-- <i>                                                                         --</i>
-- <i> This library is distributed in the hope that it will be useful, but     --</i>
-- <i> WITHOUT ANY WARRANTY; without even the implied warranty of              --</i>
-- <i> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</i>
-- <i> General Public License for more details.                                --</i>
-- <i>                                                                         --</i>
-- <i> You should have received a copy of the GNU General Public License       --</i>
-- <i> along with this library; if not, write to the Free Software Foundation, --</i>
-- <i> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</i>
-- <i>                                                                         --</i>
-- <i> As a special exception, if other files instantiate generics from this   --</i>
-- <i> unit, or you link this unit with other files to produce an executable,  --</i>
-- <i> this  unit  does not  by itself cause  the resulting executable to be   --</i>
-- <i> covered by the GNU General Public License. This exception does not      --</i>
-- <i> however invalidate any other reasons why the executable file  might be  --</i>
-- <i> covered by the  GNU Public License.                                     --</i>
------------------------------------------------------------------------------

-- <i> $Id$</i>

<b>package</b> Templates_Parser.Debug <b>is</b>

   <b>procedure</b> Print (T : <b>in</b> Tag);
   -- <i> Print tag representation</i>

   <b>procedure</b> Print_Tree (Filename : <b>in</b> String);
   -- <i> Print tree for template Filename</i>

<b>end</b> Templates_Parser.Debug;

</pre>

<p><hr>
Node:<a name="Templates_Parser.Utils">Templates_Parser.Utils</a>,
Next:<a rel=next accesskey=n href="#Templates_Parser.XML">Templates_Parser.XML</a>,
Previous:<a rel=previous accesskey=p href="#Templates_Parser.Debug">Templates_Parser.Debug</a>,
Up:<a rel=up accesskey=u href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>
<br>

<h3>Templates_Parser.Utils</h3>

<br><pre>
------------------------------------------------------------------------------
-- <i>                            Templates Parser                             --</i>
-- <i>                                                                         --</i>
-- <i>                           Copyright (C) 2004                            --</i>
-- <i>                              Pascal Obry                                --</i>
-- <i>                                                                         --</i>
-- <i> This library is free software; you can redistribute it and/or modify    --</i>
-- <i> it under the terms of the GNU General Public License as published by    --</i>
-- <i> the Free Software Foundation; either version 2 of the License, or (at   --</i>
-- <i> your option) any later version.                                         --</i>
-- <i>                                                                         --</i>
-- <i> This library is distributed in the hope that it will be useful, but     --</i>
-- <i> WITHOUT ANY WARRANTY; without even the implied warranty of              --</i>
-- <i> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</i>
-- <i> General Public License for more details.                                --</i>
-- <i>                                                                         --</i>
-- <i> You should have received a copy of the GNU General Public License       --</i>
-- <i> along with this library; if not, write to the Free Software Foundation, --</i>
-- <i> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</i>
-- <i>                                                                         --</i>
-- <i> As a special exception, if other files instantiate generics from this   --</i>
-- <i> unit, or you link this unit with other files to produce an executable,  --</i>
-- <i> this  unit  does not  by itself cause  the resulting executable to be   --</i>
-- <i> covered by the GNU General Public License. This exception does not      --</i>
-- <i> however invalidate any other reasons why the executable file  might be  --</i>
-- <i> covered by the  GNU Public License.                                     --</i>
------------------------------------------------------------------------------

-- <i> $Id$</i>

<b>package</b> Templates_Parser.Utils <b>is</b>

   <b>function</b> Image (T : <b>in</b> Tag) <b>return</b> String;
   -- <i> Returns a string representation for this tag</i>

   <b>function</b> Value (T : <b>in</b> String) <b>return</b> Tag;
   -- <i> Give a string representation of a tag (as encoded with Image above),</i>
   -- <i> build the corresponding Tag object. Raises Constraint_Error if T is</i>
   -- <i> not a valid tag representation.</i>

<b>end</b> Templates_Parser.Utils;

</pre>

<p><hr>
Node:<a name="Templates_Parser.XML">Templates_Parser.XML</a>,
Previous:<a rel=previous accesskey=p href="#Templates_Parser.Utils">Templates_Parser.Utils</a>,
Up:<a rel=up accesskey=u href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>
<br>

<h3>Templates_Parser.XML</h3>

<br><pre>
------------------------------------------------------------------------------
-- <i>                            Templates Parser                             --</i>
-- <i>                                                                         --</i>
-- <i>                           Copyright (C) 2004                            --</i>
-- <i>                              Pascal Obry                                --</i>
-- <i>                                                                         --</i>
-- <i> This library is free software; you can redistribute it and/or modify    --</i>
-- <i> it under the terms of the GNU General Public License as published by    --</i>
-- <i> the Free Software Foundation; either version 2 of the License, or (at   --</i>
-- <i> your option) any later version.                                         --</i>
-- <i>                                                                         --</i>
-- <i> This library is distributed in the hope that it will be useful, but     --</i>
-- <i> WITHOUT ANY WARRANTY; without even the implied warranty of              --</i>
-- <i> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</i>
-- <i> General Public License for more details.                                --</i>
-- <i>                                                                         --</i>
-- <i> You should have received a copy of the GNU General Public License       --</i>
-- <i> along with this library; if not, write to the Free Software Foundation, --</i>
-- <i> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</i>
-- <i>                                                                         --</i>
-- <i> As a special exception, if other files instantiate generics from this   --</i>
-- <i> unit, or you link this unit with other files to produce an executable,  --</i>
-- <i> this  unit  does not  by itself cause  the resulting executable to be   --</i>
-- <i> covered by the GNU General Public License. This exception does not      --</i>
-- <i> however invalidate any other reasons why the executable file  might be  --</i>
-- <i> covered by the  GNU Public License.                                     --</i>
------------------------------------------------------------------------------

-- <i> $Id$</i>

-- <i> This API provides a way to save a Translate_Set as an XML document.</i>
-- <i> There is special rules to know about composite tags.</i>
--
-- <i> Composite tags :</i>
--
-- <i>    If a tag named TAG exists, then the name TAG_DESCRIPTION is used as a</i>
-- <i>    description for this specific tag.</i>
--
-- <i> Composite tags (more than one nested level)</i>
--
-- <i>    If a tag named TAG exists, then the names TAG_DIM[n]_LABELS is used as</i>
-- <i>    a set of labels for the tag's nth axis. In this case TAG_DIM[n]_LABELS</i>
-- <i>    must be a vector tag, each entry corresponds to a label on this</i>
-- <i>    axis. Also TAG_DIM[n]_DESCRIPTION is used as a description for this</i>
-- <i>    axis.</i>
--
-- <i> Here is the DTD :</i>
--
-- <i> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</i>
-- <i> &lt;!--Description of a tag or dimension (ex: year)--&gt;</i>
-- <i> &lt;!ELEMENT Description (#PCDATA)&gt;</i>
-- <i> &lt;!--a dimension--&gt;</i>
-- <i> &lt;!ELEMENT Dim (Description, Labels)&gt;</i>
-- <i> &lt;!ATTLIST Dim</i>
-- <i>     n CDATA #REQUIRED</i>
-- <i> &gt;</i>
-- <i> &lt;!--entry of a CompositeTag--&gt;</i>
-- <i> &lt;!ELEMENT Entry (ind+, V)&gt;</i>
-- <i> &lt;!--label of an indice of a dimension (ex: 2000)--&gt;</i>
-- <i> &lt;!ELEMENT Label (#PCDATA)&gt;</i>
-- <i> &lt;!ATTLIST Label</i>
-- <i>     ind CDATA #REQUIRED</i>
-- <i> &gt;</i>
-- <i> &lt;!--list of labels of one dimension (ex: 1999, 2000, 2001)--&gt;</i>
-- <i> &lt;!ELEMENT Labels (Label+)&gt;</i>
-- <i> &lt;!--alias and information--&gt;</i>
-- <i> &lt;!ELEMENT Tag (Name, Description)&gt;</i>
-- <i> &lt;!--tagged data to be published in templates--&gt;</i>
-- <i> &lt;!ELEMENT Tagged (SimpleTag*, CompositeTag*)&gt;</i>
-- <i> &lt;!--simple variable value--&gt;</i>
-- <i> &lt;!ELEMENT V (#PCDATA)&gt;</i>
-- <i> &lt;!ELEMENT ind (#PCDATA)&gt;</i>
-- <i> &lt;!ATTLIST ind</i>
-- <i>     n CDATA #REQUIRED</i>
-- <i> &gt;</i>
-- <i> &lt;!--identification name for this tag--&gt;</i>
-- <i> &lt;!ELEMENT Name (#PCDATA)&gt;</i>
-- <i> &lt;!--Tag with no dimension (simple variable)--&gt;</i>
-- <i> &lt;!ELEMENT SimpleTag (Tag, V)&gt;</i>
-- <i> &lt;!--Tag with one or more dimensions--&gt;</i>
-- <i> &lt;!ELEMENT CompositeTag (Tag, Dim+, Entry)&gt;</i>

<b>package</b> Templates_Parser.XML <b>is</b>

   <b>function</b> Image (Translations : <b>in</b> Translate_Set) <b>return</b> Unbounded_String;
   -- <i> Returns a string representation encoded in XML for this</i>
   -- <i> translate table.</i>

   <b>function</b> Value (Translations : <b>in</b> String) <b>return</b> Translate_Set;
   -- <i> Returns a translate set for this string representation</i>

   <b>function</b> Value (Translations : <b>in</b> Unbounded_String) <b>return</b> Translate_Set;
   -- <i> Save as above but based on an Ubounded_String</i>

   <b>function</b> Load (Filename : <b>in</b> String) <b>return</b> Translate_Set;
   -- <i> Read XML document Filename and create the corresponding Translate_set</i>

   <b>procedure</b> Save (Filename : <b>in</b> String; Translations : <b>in</b> Translate_Set);
   -- <i> Write the translate table into filename</i>

<b>end</b> Templates_Parser.XML;

</pre>

<p><hr>
Node:<a name="Index">Index</a>,
Previous:<a rel=previous accesskey=p href="#Templates_Parser%20API%20Reference">Templates_Parser API Reference</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Index</h2>

<ul compact>
<li>@_DAY_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_DAY_NAME_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_HOUR_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_MINUTE_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_MONTH_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_MONTH_NAME_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_NOW_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_NUMBER_LINE_@: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>@_SECOND_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>@_TABLE_LEVEL_@: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>@_TABLE_LINE_@: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>@_UP_TABLE_LINE_@: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>@_YEAR_@: <a href="#Other%20variable%20tags">Other variable tags</a>
<li>Attribute, 'Length: <a href="#Attributes">Attributes</a>
<li>Attribute, 'Line: <a href="#Attributes">Attributes</a>
<li>Attribute, 'Max_Column: <a href="#Attributes">Attributes</a>
<li>Attribute, 'Min_Column: <a href="#Attributes">Attributes</a>
<li>Attribute, 'Up_Level: <a href="#Attributes">Attributes</a>
<li>Command, @@-: <a href="#Comments%20tag%20statement">Comments tag statement</a>
<li>Command, comments: <a href="#Comments%20tag%20statement">Comments tag statement</a>
<li>Command, IF: <a href="#IF%20tag%20statement">IF tag statement</a>
<li>Command, IF expression: <a href="#IF%20tag%20statement">IF tag statement</a>
<li>Command, INCLUDE: <a href="#INCLUDE%20tag%20statement">INCLUDE tag statement</a>
<li>Command, SET: <a href="#SET%20tag%20statement">SET tag statement</a>
<li>Command, TABLE: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>Command, TERMINATE_SECTIONS: <a href="#TABLE%20tag%20statement">TABLE tag statement</a>
<li>Context: <a href="#Context">Context</a>
<li>Debug: <a href="#Debug">Debug</a>
<li>Filter, "*": <a href="#Filters">Filters</a>
<li>Filter, "+": <a href="#Filters">Filters</a>
<li>Filter, "-": <a href="#Filters">Filters</a>
<li>Filter, "/": <a href="#Filters">Filters</a>
<li>Filter, ABS: <a href="#Filters">Filters</a>
<li>Filter, ADD_PARAM: <a href="#Filters">Filters</a>
<li>Filter, BR_2_LF: <a href="#Filters">Filters</a>
<li>Filter, CAPITALIZE: <a href="#Filters">Filters</a>
<li>Filter, CLEAN_TEXT: <a href="#Filters">Filters</a>
<li>Filter, COMA_2_POINT: <a href="#Filters">Filters</a>
<li>Filter, CONTRACT: <a href="#Filters">Filters</a>
<li>Filter, DEL_PARAM: <a href="#Filters">Filters</a>
<li>Filter, EXIST: <a href="#Filters">Filters</a>
<li>Filter, FILE_EXISTS: <a href="#Filters">Filters</a>
<li>Filter, FORMAT_DATE: <a href="#Filters">Filters</a>
<li>Filter, FORMAT_NUMBER: <a href="#Filters">Filters</a>
<li>Filter, IS_EMPTY: <a href="#Filters">Filters</a>
<li>Filter, LF_2_BR: <a href="#Filters">Filters</a>
<li>Filter, LOWER: <a href="#Filters">Filters</a>
<li>Filter, MATCH: <a href="#Filters">Filters</a>
<li>Filter, MAX: <a href="#Filters">Filters</a>
<li>Filter, MIN: <a href="#Filters">Filters</a>
<li>Filter, MOD: <a href="#Filters">Filters</a>
<li>Filter, NEG: <a href="#Filters">Filters</a>
<li>Filter, NO_CONTEXT: <a href="#Filters">Filters</a>
<li>Filter, NO_DIGIT: <a href="#Filters">Filters</a>
<li>Filter, NO_LETTER: <a href="#Filters">Filters</a>
<li>Filter, NO_SPACE: <a href="#Filters">Filters</a>
<li>Filter, OUI_NON: <a href="#Filters">Filters</a>
<li>Filter, POINT_2_COMA: <a href="#Filters">Filters</a>
<li>Filter, REPEAT: <a href="#Filters">Filters</a>
<li>Filter, REPLACE: <a href="#Filters">Filters</a>
<li>Filter, REPLACE_ALL: <a href="#Filters">Filters</a>
<li>Filter, REPLACE_PARAM: <a href="#Filters">Filters</a>
<li>Filter, REVERSE: <a href="#Filters">Filters</a>
<li>Filter, SIZE: <a href="#Filters">Filters</a>
<li>Filter, SLICE: <a href="#Filters">Filters</a>
<li>Filter, TRIM: <a href="#Filters">Filters</a>
<li>Filter, UPPER: <a href="#Filters">Filters</a>
<li>Filter, WEB_ESCAPE: <a href="#Filters">Filters</a>
<li>Filter, WEB_NBSP: <a href="#Filters">Filters</a>
<li>Filter, YES_NO: <a href="#Filters">Filters</a>
<li>Filters: <a href="#Filters%20and%20Attributes">Filters and Attributes</a>
<li>Tag utils: <a href="#Tag%20utils">Tag utils</a>
<li>Tag, boolean: <a href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>
<li>Tag, composite: <a href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>
<li>Tag, discrete: <a href="#Discrete%20Boolean%20Composite">Discrete Boolean Composite</a>
<li>Templates_Parser: <a href="#Templates_Parser">Templates_Parser</a>
<li>Templates_Parser.Debug: <a href="#Templates_Parser.Debug">Templates_Parser.Debug</a>
<li>Templates_Parser.Utils: <a href="#Templates_Parser.Utils">Templates_Parser.Utils</a>
<li>Templates_Parser.XML: <a href="#Templates_Parser.XML">Templates_Parser.XML</a>
<li>Translate_Set: <a href="#Translations">Translations</a>
<li>Translate_Table: <a href="#Translations">Translations</a>
<li>XML: <a href="#XML%20representation">XML representation</a>
</ul>


</body></html>

