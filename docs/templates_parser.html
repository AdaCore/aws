<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from templates_parser.texi on 12 May 2004 -->

<TITLE>Templates Parser</TITLE>
</HEAD>
<BODY>
<H1>Templates Parser</H1>
<H2>$Revision$</H2>
<H2>Date: 12 May 2004</H2>
<ADDRESS>Pascal Obry (<A HREF="mailto:pascal@obry.org">pascal@obry.org</A>)</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="templates_parser.html#SEC1">Introduction</A>
<LI><A NAME="TOC2" HREF="templates_parser.html#SEC2">What is a tag ?</A>
<LI><A NAME="TOC3" HREF="templates_parser.html#SEC3">Variable tags</A>
<UL>
<LI><A NAME="TOC4" HREF="templates_parser.html#SEC4">Discrete Boolean Composite</A>
<LI><A NAME="TOC5" HREF="templates_parser.html#SEC5">Filters and Attributes</A>
<UL>
<LI><A NAME="TOC6" HREF="templates_parser.html#SEC6">Filters</A>
<LI><A NAME="TOC7" HREF="templates_parser.html#SEC7">Attributes</A>
</UL>
<LI><A NAME="TOC8" HREF="templates_parser.html#SEC8">Other variable tags</A>
</UL>
<LI><A NAME="TOC9" HREF="templates_parser.html#SEC9">Translations</A>
<LI><A NAME="TOC10" HREF="templates_parser.html#SEC10">Tag statements</A>
<UL>
<LI><A NAME="TOC11" HREF="templates_parser.html#SEC11">Comments tag statement</A>
<LI><A NAME="TOC12" HREF="templates_parser.html#SEC12">INCLUDE tag statement</A>
<LI><A NAME="TOC13" HREF="templates_parser.html#SEC13">IF tag statement</A>
<LI><A NAME="TOC14" HREF="templates_parser.html#SEC14">TABLE tag statement</A>
</UL>
<LI><A NAME="TOC15" HREF="templates_parser.html#SEC15">Last notes</A>
<LI><A NAME="TOC16" HREF="templates_parser.html#SEC16">Templates_Parser Ada spec</A>
</UL>
<P><HR><P>



<H1><A NAME="SEC1" HREF="templates_parser.html#TOC1">Introduction</A></H1>

<P>
First of all this package is distributed under the GNAT modified GNU GPL.

</P>
<P>
The templates parser package has been designed to parse files and to
replace some specific tags into these files by some specified values.

</P>
<P>
The main goal was to ease the development of Web servers. In CGI 
(<I>Common Gateway Interface</I>) mode you have to write the HTML page in
the program (in Ada or whatever other languages) by using some specific
libraries or by using only basic output functions like Ada <CODE>Put_Line</CODE> for
example. This is of course not mandatory but by lack of a good library
every Web development end up doing just that.

</P>
<P>
The main problems with this approach are:

</P>

<UL>

<LI>It is painful to have to recompile the program each time you have

a slight change to do in the design (center an image, change the border
width of a table...)

<LI>You have the design and the program merged together. It means that

to change the design you must know the Ada language. And to change the
Ada program you need to understand what is going on with all these
inline HTML command.

<LI>You can't use the nice tools to generate your HTML.

</UL>

<P>
With the templates parser package these problems are gone. The code and
the design is <B>completely</B> separated. This is a very important
point. PHP or JSP have tried this but most of the time you have the
script embedded into the Web template. And worst you need to use another
language just for your Web development.

</P>

<UL>

<LI>The HTML page is separated from the program code. Then you can

change the design without changing the code. Moreover when you fix the
code you don't have to handle all the specific HTML output. And you do
not risk to break the design.

<LI>It is easier to work on the design and the program at the same time

using the right peoples for the job.

<LI>It reduce the number of <I>edit/build/test</I> cycles. Writing HTML

code from a program is error prone.

<LI>It is possible to use standard tools to produce the HTML.

<LI>You don't have to learn a new language.

<LI>The script is Ada, so here you have the benefit of all the Ada power.

</UL>

<P>
In fact, now the Ada program just compute some values, get some data
from a database or whatever and then call the templates parser to output
a page with the data displayed. To the templates parser you just pass
the template filename and an associative table. 

</P>
<P>
It is even more convenient to have different display with the same set
of data. You just have to provides as many templates as you like.

</P>



<H1><A NAME="SEC2" HREF="templates_parser.html#TOC2">What is a tag ?</A></H1>

<P>
A tag is a string found in the template page and surrounded by a specific set
of characters. The default is <B>@_</B> at the start and <B>_@</B> at the
end of the tag. This default can be changed using <CODE>Set_Tag_Separators</CODE>
routine, see section <A HREF="templates_parser.html#SEC16">Templates_Parser Ada spec</A>. Note that it must be changed
as the first API call and should not be changed after that.

</P>
<P>
The tag will be replaced by a value specified in a translation table.

</P>
<P>
For example with the template file <TT>`demo.tmplt'</TT>:

</P>

<PRE>

&#60;P&#62;Hello @_NAME_@

</PRE>

<P>
Using the following code <TT>`demo.adb'</TT>:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Demo <B>is</B>

   Translations : <B>constant</B> Templates_Parser.Translate_Table
     := (1 =&#62; Templates_Parser.Assoc ("<I>NAME</I>", "<I>Ada</I>"));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>demo.tmplt</I>", Translations));
<B>end</B> Demo;

</PRE>

<P>
The program will print out :

</P>

<PRE>
&#60;P&#62;Hello Ada
</PRE>

<P>
This is a very simple example, but you'll see that there is a lot of
powerful construct that you can use into a template file.

</P>



<H1><A NAME="SEC3" HREF="templates_parser.html#TOC3">Variable tags</A></H1>


<UL>
<LI><A HREF="templates_parser.html#SEC4">Discrete Boolean Composite</A>
<LI><A HREF="templates_parser.html#SEC5">Filters and Attributes</A>
<LI><A HREF="templates_parser.html#SEC8">Other variable tags</A>
</UL>



<H2><A NAME="SEC4" HREF="templates_parser.html#TOC4">Discrete Boolean Composite</A></H2>

<P>
A variable tag is a specific string to be replaced by the template
parser. There is three kinds of variable tags: <B>discrete</B>, <B>boolean</B>,
<B>composite</B>. All variables tags are built using the <CODE>Assoc</CODE>
constructors, see section <A HREF="templates_parser.html#SEC16">Templates_Parser Ada spec</A>.

</P>
<DL COMPACT>

<DT><B>discrete</B>
<DD>
We have already seen the discrete variable tag. This is a variable which
has only one value. This value will replace the tag in the template
file. Discrete variable constructors are provided for String,
Unbounded_String and Integer (see Assoc routines).
<P>

<DT><B>boolean</B>
<DD>
A boolean tag as a value of TRUE or FALSE. This value will replace the
tag in the template file. These tags can also be used with the <CODE>IF</CODE> tag
statement.
<P>

<DT><B>composite (Tag)</B>
<DD>
A composite tag is a variable which contains a set of values. These kind of
variables will be used with the <CODE>TABLE</CODE> tag statement 
see section <A HREF="templates_parser.html#SEC14">TABLE tag statement</A>. Outside a table statement it will be
replaced by all values concatenated with a specified separator. See
<CODE>Set_Separator</CODE> routine. Such tag are variables declared on the
Ada program a <CODE>Templates_Parser.Tag</CODE> type.

<P>
There is many overloaded constructors to build a composite tags (see "+"
operators).  The "+" operators are used to build a Tag item from
standard types like String, Unbounded_String, Character, Integer and
Boolean.

<P>
To add items to a Tag many overloaded operators are provided (see
"&#38;" operators). The "&#38;" operators add one item at the start or the end
of the tag, it is possible to add directly String, Unbounded_String,
Character, Integer and Boolean items using one of the overloaded operator.

<P>
A tag composed of only boolean values TRUE or FALSE is called a
Boolean composite tag. This tag is to be used with a <CODE>IF</CODE> tag statement
inside a <CODE>TABLE</CODE> tag statement.

<P>
It is possible to build a composite tag having any number of nested
level. A vector is a composite tag with only one level, a matrix is a
composite tag with two level (a Tag with a set of vector tag).

<P>
Two aliases exists for composite tags with one or two nested level,
they are named <CODE>Vector_Tag</CODE> and <CODE>Matrix_Tag</CODE>. In the suite
of the document, we call <I>vector tag</I> a tag with a single nested
level and <I>matrix tag</I> a tag with two nested level.

</DL>



<H2><A NAME="SEC5" HREF="templates_parser.html#TOC5">Filters and Attributes</A></H2>

<P>
All kinds of variable tag can have one or more function-prefix or
filter. The function prefix is applied to the variable value. The
syntax is
<CODE>@_[[FILTER_NAME[(parameter)]:]FILTER_NAME[(parameter)]:]SOME_VAR_@</CODE>.
Filters are evaluated from right to left.

</P>
<P>
Composite tags can also have attributes. Attributes are placed
after the tag name and preceded with a simple quote.
<CODE>@_SOME_VAR['ATTRIBUTE_NAME]_@</CODE>. It is possible to use filters
and attributes together. In that case the attribute is first evaluated and
the result is passed-through the filters.

</P>

<UL>
<LI><A HREF="templates_parser.html#SEC6">Filters</A>
<LI><A HREF="templates_parser.html#SEC7">Attributes</A>
</UL>



<H3><A NAME="SEC6" HREF="templates_parser.html#TOC6">Filters</A></H3>

<P>
The current supported filters are:

</P>
<DL COMPACT>

<DT><CODE>"+"(<I>N</I>) or ADD(<I>N</I>)</CODE>
<DD>
Add N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<DT><CODE>"-"(<I>N</I>) or SUB(<I>N</I>)</CODE>
<DD>
Subtract N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<DT><CODE>"*"(<I>N</I>) or MULT(<I>N</I>)</CODE>
<DD>
Multiply N with variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<DT><CODE>"/"(<I>N</I>) or DIV(<I>N</I>)</CODE>
<DD>
Divide variable by N and return the result. If the current variable value
is not a number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<DT><CODE>ADD_PARAM(<I>NAME[=VALUE]</I>)</CODE>
<DD>
Add a parameter into an URL. This routine adds the '?' and '&#38;'
character if needed. <I>VALUE</I> can be a tag variable name.

<DT><CODE>BR_2_LF</CODE>
<DD>
Replaces all occurrences of the <CODE>&#60;br&#62;</CODE> HTML tag by a LF
(Line-Feed) character.

<DT><CODE>CAPITALIZE</CODE>
<DD>
Put all characters in the variable in lower case except characters after
a space or an underscore which are set in upper-case.

<DT><CODE>CLEAN_TEXT</CODE>
<DD>
Keep only letters and digits all others characters are changed to
spaces.

<DT><CODE>COMA_2_POINT</CODE>
<DD>
Replaces all comas by points.

<DT><CODE>CONTRACT</CODE>
<DD>
Converts any suite of spaces by a single space character.

<DT><CODE>DEL_PARAM(<I>NAME</I>)</CODE>
<DD>
Delete parameter NAME from the URL. This routine removes the '?' and '&#38;'
character if needed. Returns the input string as-is if the parameter
is not found.

<DT><CODE>EXIST</CODE>
<DD>
Returns <B>True</B> if variable is set and has a value different that the null
string and <B>False</B> otherwise.

<DT><CODE>FORMAT_DATE(<B>FORMAT</B>)</CODE>
<DD>
Returns the date with the given format. The date must be in the ISO
format (YYYY-MM-DD) eventually followed by a space and the time with
the format HH:MM:SS. If the date is not given in the right format it
returns the date as-is. The format is using the GNU/date description
patterns as also implemented in <CODE>GNAT.Calendar.Time_IO</CODE>.

<P>

<DL COMPACT>

<DT><I>Characters:</I>
<DD>
<DL COMPACT>

<DT><B>%</B>
<DD>
a literal %
<DT><B>n</B>
<DD>
a newline
<DT><B>t</B>
<DD>
a horizontal tab
</DL>

<DT><I>Time fields:</I>
<DD>
<DL COMPACT>

<DT><B>%H</B>
<DD>
hour (00..23)
<DT><B>%I</B>
<DD>
hour (01..12)
<DT><B>%k</B>
<DD>
hour ( 0..23)
<DT><B>%l</B>
<DD>
hour ( 1..12)
<DT><B>%M</B>
<DD>
minute (00..59)
<DT><B>%p</B>
<DD>
locale's AM or PM
<DT><B>%r</B>
<DD>
time, 12-hour (hh:mm:ss [AP]M)
<DT><B>%s</B>
<DD>
seconds  since 1970-01-01  00:00:00 UTC (a nonstandard extension)
<DT><B>%S</B>
<DD>
second (00..59)
<DT><B>%T</B>
<DD>
time, 24-hour (hh:mm:ss)
</DL>

<DT><I>Date fields:</I>
<DD>
<DL COMPACT>

<DT><B>%a</B>
<DD>
locale's abbreviated weekday name (Sun..Sat)
<DT><B>%A</B>
<DD>
locale's full weekday name, variable length (Sunday..Saturday)
<DT><B>%b</B>
<DD>
locale's abbreviated month name (Jan..Dec)
<DT><B>%B</B>
<DD>
locale's full month name, variable length (January..December)
<DT><B>%c</B>
<DD>
locale's date and time (Sat Nov 04 12:02:33 EST 1989)
<DT><B>%d</B>
<DD>
day of month (01..31)
<DT><B>%D</B>
<DD>
date (mm/dd/yy)
<DT><B>%h</B>
<DD>
same as %b
<DT><B>%j</B>
<DD>
day of year (001..366)
<DT><B>%m</B>
<DD>
month (01..12)
<DT><B>%U</B>
<DD>
week number of year with  Sunday as first day of week (00..53)
<DT><B>%w</B>
<DD>
day of week (0..6) with 0 corresponding to Sunday
<DT><B>%W</B>
<DD>
week number of year with  Monday as first day of week (00..53)
<DT><B>%x</B>
<DD>
locale's date representation (mm/dd/yy)
<DT><B>%y</B>
<DD>
last two digits of year (00..99)
<DT><B>%Y</B>
<DD>
year (1970...)
</DL>

<DT><I>By default,  date pads numeric fields with zeroes. GNU date recognizes the following nonstandard numeric modifiers:</I>
<DD>
<DL COMPACT>

<DT><B>-    (hyphen)</B>
<DD>
do not pad the field
<DT><B>_    (underscore)</B>
<DD>
pad the field with spaces
</DL>
</DL>

<DT><CODE>FORMAT_NUMBER</CODE>
<DD>
Returns the number with a space added between each 3 digits
blocks. The decimal part is not transformed. If the data is not a
number nothing is done.

<DT><CODE>IS_EMPTY</CODE>
<DD>
Returns <B>True</B> if variable is the empty string and <B>False</B> otherwise.

<DT><CODE>LF_2_BR</CODE>
<DD>
Replaces all occurrences of the character LF (Line-Feed) by a
<CODE>&#60;br&#62;</CODE> HTML tag.

<DT><CODE>LOWER</CODE>
<DD>
Put all characters in the variable in lower-case.

<DT><CODE>MATCH(<I>REGEXP</I>)</CODE>
<DD>
Returns <B>True</B> if variable match the regular expression passed as
filter's parameter. The regular expression is using a format as
found in <TT>`gawk'</TT>, <TT>`sed'</TT> or <TT>`grep'</TT> tools.

<DT><CODE>MOD(<I>N</I>)</CODE>
<DD>
Returns variable modulo N. If the current variable value is not a
number it returns the empty string. N must be a number or a
discrete tag variable whose value is a number.

<DT><CODE>NO_DIGIT</CODE>
<DD>
Replaces all digits by spaces.

<DT><CODE>NO_LETTER</CODE>
<DD>
Replaces all letters by spaces.

<DT><CODE>NO_SPACE</CODE>
<DD>
Removes all spaces in the variable.

<DT><CODE>OUI_NON</CODE>
<DD>
If variable value is <B>True</B> it returns <B>Oui</B>, if <B>False</B> it
returns <B>Non</B>, otherwise does nothing. It keeps the way <B>True/False</B> is
capitalized (all upper, all lower or first letter capital).

<DT><CODE>POINT_2_COMA</CODE>
<DD>
Replaces all comas by points.

<DT><CODE>REPEAT(<I>N</I>)</CODE>
<DD>
Returns N times the variable, N being passed as filter's parameter. N
must be a number  or a discrete tag variable whose value is a number.

<DT><CODE>REPLACE(<I>REGEXP</I>[/<I>STR</I>])</CODE>
<DD>
This filter replaces <B>\n</B> (where <I>n</I> is a number) <I>STR</I>'s
occurences by the corresponding match from <I>REGEXP</I>. The first match
in <I>REGEXP</I> will replace <B>\1</B>, the second match <B>\2</B> and so
on. Each match in <I>REGEXP</I> must be parenthesized. It replaces only
the first match. <I>STR</I> is an optional parameter, its default value
is <B>\1</B>. <I>STR</I> can be a tag variable name.

<DT><CODE>REPLACE_ALL(<I>REGEXP</I>[/<I>STR</I>])</CODE>
<DD>
Idem as above but replaces all occurences.

<DT><CODE>REPLACE_PARAM(<I>NAME[=VALUE]</I>)</CODE>
<DD>
This is filter is equivalent to 
ADD_PARAM(<I>NAME[=VALUE]</I>):DEL_PARAM(<I>NAME</I>). <I>VALUE</I> can be a
tag variable name.

<DT><CODE>REVERSE</CODE>
<DD>
Reverse the string.

<DT><CODE>SIZE</CODE>
<DD>
Returns the size (number of characters) of the string value.

<DT><CODE>SLICE(<I>x .. y</I>)</CODE>
<DD>
Returns the sub-string starting from position x and ending to position
y. Note that the string to slice always start from position 1.

<DT><CODE>TRIM</CODE>
<DD>
Removes leading and trailing spaces.

<DT><CODE>UPPER</CODE>
<DD>
Put all characters in the variable in upper-case.

<DT><CODE>WEB_ESCAPE</CODE>
<DD>
Replaces characters '&#60;', '&#62;', '"' and '&#38;' by corresponding HTML
sequences: &#38;lt; &#38;gt; &#38;quot; and &#38;amp; 

<DT><CODE>WEB_NBSP</CODE>
<DD>
Replaces all spaces by an HTML non breaking space.

<DT><CODE>YES_NO</CODE>
<DD>
If variable value is <B>True</B> it returns <B>Yes</B>, if <B>False</B> it
returns <B>No</B>, otherwise does nothing. It keeps the way <B>True/False</B> is
capitalized (all upper, all lower or first letter capital).

</DL>

<P>
For example:

</P>

<PRE>
If VAR is set to "<I>vector_tag</I>", ONE to "1" and TWO to "2" then:

@_VAR_@                                   -&#62;  vector_tag
@_UPPER:VAR_@                             -&#62;  VECTOR_TAG
@_CAPITALIZE:VAR_@                        -&#62;  Vector_Tag
@_EXIST:VAR_@                             -&#62;  TRUE
@_UPPER:REVERSE:VAR_@                     -&#62;  GAT_ROTCEV
@_MATCH(VEC.*):UPPER:VAR_@                -&#62;  TRUE
@_SLICE(1..6):VAR_@                       -&#62;  vector
@_REPLACE(([^_]+)):VAR_@                  -&#62;  vector
@_REPLACE(([a-z]+)_([a-z]+)/\2_\1):VAR_@  -&#62;  tag_vector
@_"+"(TWO):ONE_@                          -&#62;  3
@_"-"(TWO):ONE_@                          -&#62;  -1
</PRE>



<H3><A NAME="SEC7" HREF="templates_parser.html#TOC7">Attributes</A></H3>

<P>
Current supported attributes are:

</P>
<DL COMPACT>

<DT><CODE>V'length</CODE>
<DD>
Returns the number of item in the composite tag (can be applied only
to a composite tag having a single nested level - a vector).

<DT><CODE>M'Line</CODE>
<DD>
Returns the number of line in the composite tag. This is identical to
'Length but can be applied only to a composite tag having two nested
level - a matrix).

<DT><CODE>M'Min_Column</CODE>
<DD>
Returns the size of smallest composite tag in M composite tag. This attribute
can be applied only to a composite tag having two nested level - a matrix.

<DT><CODE>M'Max_Column</CODE>
<DD>
Returns the size of largest composite tag in M composite tag. This attribute
can be applied only to a composite tag having two nested level - a matrix.

</DL>

<P>
For example:

</P>

<PRE>
If VEC is set to "<I>&#60;1 , 2&#62;</I>" and MAT to "<I>&#60;a, b, c&#62; ; &#60;2, 3, 5, 7&#62;</I>" then:

@_VEC'Length_@              -&#62;  2
@_ADD(3):VEC'Length_@       -&#62;  5
@_MAT'Line_@                -&#62;  2
@_MAT'Min_Column_@          -&#62;  3
@_MAT'Max_Column_@          -&#62;  4

</PRE>



<H2><A NAME="SEC8" HREF="templates_parser.html#TOC8">Other variable tags</A></H2>

<P>
There is some specific variables tags that can be used in any
templates. Here is a description of them:

</P>
<DL COMPACT>

<DT><CODE>NOW</CODE>
<DD>
Current date and time with format "YYYY-MM-DD HH:MM:SS".

<DT><CODE>YEAR</CODE>
<DD>
Current year number using 4 digits.

<DT><CODE>MONTH</CODE>
<DD>
Current month number using 2 digits.

<DT><CODE>DAY</CODE>
<DD>
Current day number using 2 digits.

<DT><CODE>HOUR</CODE>
<DD>
Current hour using range 0 to 23 using 2 digits.

<DT><CODE>MINUTE</CODE>
<DD>
Current minute using 2 digits.

<DT><CODE>SECOND</CODE>
<DD>
Current seconds using 2 digits.

<DT><CODE>MONTH_NAME</CODE>
<DD>
Current full month name (January .. December).

<DT><CODE>DAY_NAME</CODE>
<DD>
Current full day name (Monday .. Sunday).

</DL>



<H1><A NAME="SEC9" HREF="templates_parser.html#TOC9">Translations</A></H1>

<P>
Associations between variable tags and the template tag names are
created with one of the <CODE>Assoc</CODE> routines. This set of
associations are used by the parser (<CODE>Parse</CODE> routine). There is
two kinds of associations set:

</P>

<UL>

<LI>Translate_Table

an array of associations, this is easy to use when the number of
associations is known at the creation time.

<LI>Translate_Set

a set of associations, it is possible to insert as many associations
as needed into this object.
</UL>

<P>
Note that this difference is only for users, the Templates_Parser
engine uses only <CODE>Translate_Set</CODE> objects internally as it is much more
efficient.

</P>



<H1><A NAME="SEC10" HREF="templates_parser.html#TOC10">Tag statements</A></H1>

<P>
There is three different tag statements. A tag statement is surrounded
by <CODE>@@</CODE>. The tag statements are:

</P>

<UL>
<LI><A HREF="templates_parser.html#SEC11">Comments tag statement</A>
<LI><A HREF="templates_parser.html#SEC12">INCLUDE tag statement</A>
<LI><A HREF="templates_parser.html#SEC13">IF tag statement</A>
<LI><A HREF="templates_parser.html#SEC14">TABLE tag statement</A>
</UL>



<H2><A NAME="SEC11" HREF="templates_parser.html#TOC11">Comments tag statement</A></H2>

<P>
Every line starting with <B>@@--</B> are comments and are completly
ignored by the parser. The resulting page will have the exact same
format and number of lines with or without the comments.

</P>

<PRE>
@@-- This template is used to display the client's data
@@-- It uses the following tags:
@@--
@@--    @_CID_@       Client ID
@@--    @_ITEMS_V_@   List of items (vector tag)

&#60;P&#62;Client @_CID_@

...
</PRE>



<H2><A NAME="SEC12" HREF="templates_parser.html#TOC12">INCLUDE tag statement</A></H2>

<P>
This tag is used to include another template file. This is useful if you
have the same header and/or footer in all your HTML pages. For example:

</P>

<PRE>
@@INCLUDE@@ header.tmplt

&#60;P&#62;This is by Web page

@@INCLUDE@@ footer.tmplt
</PRE>

<P>
It is also possible to pass arguments to the include file. These parameters
are put after the include filename. It is possible to reference these
parameters into the included file with the special variable names
<CODE>@_$&#60;n&#62;_@</CODE>, where <I>n</I> is the include's parameter indice (0 is
the include filename, 1 the first parameter and so on).

</P>

<PRE>
@@INCLUDE@@ another.tmplt @_VAR_@ azerty
</PRE>

<P>
In file <TT>`another.tmplt'</TT>

</P>
<DL COMPACT>

<DT><CODE>@_$0_@</CODE>
<DD>
is another.tmplt
<DT><CODE>@_$1_@</CODE>
<DD>
is the variable @_VAR_@
<DT><CODE>@_$2_@</CODE>
<DD>
is the string "azerty"
</DL>

<P>
If an include variable references a non existing include parameter the
tag is kept as-is.

</P>


<H2><A NAME="SEC13" HREF="templates_parser.html#TOC13">IF tag statement</A></H2>

<P>
This is the conditional tag statement. The complete form is:

</P>

<PRE>
@@IF@@ &#60;expression1&#62;
   part1
@@ELSIF@@ &#60;expression2&#62;
   part2
@@ELSE@@
   part3
@@END_IF@@
</PRE>

<P>
The part1 one will be parsed if expression1 evaluate to "TRUE", part2
will be parsed if expression2 evaluate to "TRUE" and the part3 will
be parse in any other case. The <CODE>ELSIF</CODE> and <CODE>ELSE</CODE> part are
optional.

</P>
<P>
The expression here is composed of boolean variable (or conditional
variable) and/or boolean expression. Recognized operators are:

</P>
<DL COMPACT>

<DT><CODE>A = B</CODE>
<DD>
Returns TRUE if A equal B

<DT><CODE>A /= B</CODE>
<DD>
Returns TRUE if A is not equal B

<DT><CODE>A &#62; B</CODE>
<DD>
Returns TRUE if A greater than B. If A and B are numbers it returns the
the number comparison (5 &#62; 003 = TRUE) otherwise it returns the string
comparison ("5" &#62; "003" = FALSE).

<DT><CODE>A &#62;= B</CODE>
<DD>
Returns TRUE if A greater than or equal to B. See above for rule about numbers.

<DT><CODE>A &#60; B</CODE>
<DD>
Returns TRUE if A lesser than B. See above for rule about numbers.

<DT><CODE>A &#60;= B</CODE>
<DD>
Returns TRUE if A lesser than or equal to B. See above for rule about numbers.

<DT><CODE>A and B</CODE>
<DD>
Returns TRUE if A and B is TRUE and FALSE otherwise.

<DT><CODE>A or B</CODE>
<DD>
Returns TRUE if A or B is TRUE and FALSE otherwise.

<DT><CODE>A xor B</CODE>
<DD>
Returns TRUE if either A or B (but not both) is TRUE and FALSE otherwise.

<DT><CODE>not A</CODE>
<DD>
Returns TRUE if either A is FALSE and FALSE otherwise.
</DL>

<P>
The default evaluation order is done from left to right, all operators
having the same precedence. To build an expression it is possible to
use the parentheses to change the evaluation order. A value with
spaces must be quoted as a string. So valid expressions could be:

</P>

<PRE>
@@IF@@ (@_VAR1_@ &#62; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ not (@_VAR1_@ &#62; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ (@_VAR1_@ &#62; 3) and not @_COND1_@

@@IF@@ @_VAR1_@ = "a value"
</PRE>

<P>
Note also that variables and values can be surrounded by quotes if needed.
Quotes are needed if a value contain spaces.

</P>
<P>
To generate a conditional variable tag it is possible to use the
following <B>Templates_Parser</B> function:

</P>

<PRE>
<B>function</B> Assoc (Variable  : <B>in</B> String;
                Value     : <B>in</B> Boolean;
                <B>return</B> Association;
<I>--  build an Association (Variable = Value) to be added to a</I>
<I>--  Translate_Table. It set the variable to TRUE or FALSE depending on</I>
<I>--  Value.</I>
</PRE>

<P>
Let's see an example using an <CODE>IF</CODE> tag statement. With the following
template:

</P>

<PRE>

@@IF@@ @_USER_@
   &#60;P&#62;As a <B>use</B>r you have a restricted <B>access</B> to this server.
@@ELSE@@
   &#60;P&#62;As an administrator you have full <B>access</B> to this server.
@@END_IF@@

</PRE>

<P>
The following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> User1 <B>is</B>

   Translations : <B>constant</B> Templates_Parser.Translate_Table
     := (1 =&#62; Templates_Parser.Assoc ("<I>USER</I>", True));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>user.tmplt</I>", Translations));
<B>end</B> User1;

</PRE>

<P>
Will display:

</P>

<PRE>
   &#60;P&#62;As a user you have a restricted access to this server.

</PRE>

<P>
But the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> User2 <B>is</B>

   Translations : <B>constant</B> Templates_Parser.Translate_Table
     := (1 =&#62; Templates_Parser.Assoc ("<I>USER</I>", False));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>user.tmplt</I>", Translations));
<B>end</B> User2;

</PRE>

<P>
Will display:

</P>

<PRE>
   &#60;P&#62;As an administrator you have full access to this server.

</PRE>



<H2><A NAME="SEC14" HREF="templates_parser.html#TOC14">TABLE tag statement</A></H2>

<P>
A table tag is useful to generate <CODE>HTML</CODE> table for example. Basically the
code between the <CODE>@@TABLE@@</CODE> and <CODE>@@END_TABLE@@</CODE> will
be repeated as many time as the vector tag will have of values. If many
vector tags are specified in a table statement, the code between the
table will be repeated a number of time equal to the maximum length of
all vector tags in the <CODE>TABLE</CODE> tag statement.

</P>
<P>
A <CODE>TABLE</CODE> tag statement is a kind of implicit iterator. This is a very
important concept to build HTML tables. Using a composite tag variable in
a <CODE>@@TABLE@@</CODE> tag statement it is possible to build very
complex Web pages.

</P>
<P>
Syntax:

</P>

<PRE>
@@TABLE@@ [@@TERMINATE_SECTIONS@@]
   ...
[@@SECTION@@]
   ...
@@END_TABLE@@
</PRE>

<P>
Let's have an example. With the following template:

</P>

<PRE>

&#60;P&#62;Here <B>is</B> the ages <B>of</B> some peoples:

&#60;TABLE&#62;
@@TABLE@@
   &#60;TR&#62;
   &#60;TD&#62;@_NAME_@
   &#60;TD&#62;@_AGE_@
@@END_TABLE@@
&#60;/TABLE&#62;

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   Names : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>Bob</I>" &#38; "<I>Bill</I>" &#38; "<I>Toto</I>";
   Ages  : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>10</I>" &#38; "<I>30</I>" &#38; "<I>5</I>";

   Translations : <B>constant</B> Templates_Parser.Translate_Table
     := (1 =&#62; Templates_Parser.Assoc ("<I>NAME</I>", Names),
         2 =&#62; Templates_Parser.Assoc ("<I>AGE</I>", Ages));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table.tmplt</I>", Translations));
<B>end</B> Table;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

&#60;P&#62;Here is the ages of some peoples:

&#60;TABLE&#62;
   &#60;TR&#62;
   &#60;TD&#62;Bob
   &#60;TD&#62;10
   &#60;TR&#62;
   &#60;TD&#62;Bill
   &#60;TD&#62;30
   &#60;TR&#62;
   &#60;TD&#62;Toto
   &#60;TD&#62;5
&#60;/TABLE&#62;
</PRE>

<P>
Note that we use vector tag variables here. A discrete variable tag in a table
will be replaced by the same (the only one) value for each row. A vector
tag outside a table will be displayed as a list of values, each value
being separated by a specified separator. The default is a comma and a
space ", ".

</P>
<P>
The complete prototype for the <CODE>Tag</CODE> Assoc function is:

</P>

<PRE>
   <B>function</B> Assoc (Variable  : <B>in</B> String;
                   Value     : <B>in</B> Tag;
                   Separator : <B>in</B> String    := Default_Separator;
                   <B>return</B> Association;
<I>--  Build an Association (Variable = Value) to be added to Translate_Table.</I>
<I>--  This is a tag association. Separator will be used when outputting the</I>
<I>--  a flat representation of the Tag (outside a table statement).</I>
</PRE>

<P>
A table can contain many sections. The section to use will be selected
depending on the current line. For example, a table with two sections
will use different data on even and odd lines. This is useful when you
want to alternate the line background color for a better readability
when working on HTML pages.

</P>
<P>
A table with sections can have the modifier
<CODE>@@TERMINATE_SECTIONS@@</CODE>. This ensure that the table output will end
with the last section. If the number of data in the vector variable tag
is not a multiple of the number of sections then the remaining section
will be complete with empty tag value.

</P>

<PRE>

&#60;P&#62;Here are some available computer devices:

&#60;TABLE&#62;
@@TABLE@@
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;@_DEVICES_@
   &#60;TD&#62;@_PRICES_@
@@SECTION@@
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;@_DEVICES_@
   &#60;TD&#62;@_PRICES_@
@@END_TABLE@@
&#60;/TABLE&#62;

&#60;TABLE&#62;
@@TABLE@@ @@TERMINATE_SECTIONS@@
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;@_DEVICES_@
@@SECTION@@
   &#60;TD WIDTH=150&#62;@_DEVICES_@
@@SECTION@@
   &#60;TD WIDTH=150&#62;@_DEVICES_@
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
@@END_TABLE@@
&#60;/TABLE&#62;

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table_Section <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   Devices : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>Screen</I>" &#38; "<I>Keyboard</I>" &#38; "<I>Mouse</I>" &#38; "<I>Hard Drive</I>";
   Prices  : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>$500</I>" &#38; "<I>$20</I>" &#38; "<I>$15</I>" &#38; "<I>$140</I>";

   Translations : <B>constant</B> Templates_Parser.Translate_Table
     := (1 =&#62; Templates_Parser.Assoc ("<I>DEVICES</I>", Devices),
         2 =&#62; Templates_Parser.Assoc ("<I>PRICES</I>", Prices));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table_section.tmplt</I>", Translations));
<B>end</B> Table_Section;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

&#60;P&#62;Here are some available computer devices:

&#60;TABLE&#62;
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;Screen
   &#60;TD&#62;$500
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;Keyboard
   &#60;TD&#62;$20
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;Mouse
   &#60;TD&#62;$15
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;Hard Drive
   &#60;TD&#62;$140
&#60;/TABLE&#62;

&#60;TABLE&#62;
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;Screen
   &#60;TD WIDTH=150&#62;Keyboard
   &#60;TD WIDTH=150&#62;Mouse
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;Hard Drive
   &#60;TD WIDTH=150&#62;
   &#60;TD WIDTH=150&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
&#60;/TABLE&#62;
</PRE>

<P>
Into a table construct there are some additional variable tags available:

</P>
<DL COMPACT>

<DT><CODE>@_UP_TABLE_LINE_@</CODE>
<DD>
This tag will be replaced by the table line number of the upper table
statement. It will be set to 0 outside a table statement or inside a
single table statement.

<DT><CODE>@_TABLE_LINE_@</CODE>
<DD>
This tag will be replaced by the current table line number. It will be
replaced by 0 outside a table statement.

<DT><CODE>@_NUMBER_LINE_@</CODE>
<DD>
This is the number of line displayed in the table. It will be replaced
by 0 outside a table statement.

<DT><CODE>@_TABLE_LEVEL_@</CODE>
<DD>
This is the table level number. A table construct declared in a table
has a level value of 2.  It will be replaced by 0 outside a table statement.

</DL>

<P>
Let's have a look at a more complex example with mixed IF and TABLE tag
statement.

</P>
<P>
Here is the template:

</P>

<PRE>

Hello here are a list <B>of</B> devices:

&#60;table&#62;
&#60;tr&#62;
&#60;th&#62;Device Name
&#60;th&#62;Price
&#60;th&#62;Order

@@TABLE@@
&#60;tr&#62;
&#60;td&#62;@_DEVICES_@
&#60;td&#62;@_PRICES_@

&#60;td&#62;
@@IF@@ @_AVAILABLE_@
&#60;a href="<I>/order?DEVICE=@_DEVICES_@</I>"&#62;Order
@@ELSE@@
Sorry, not available
@@END_IF@@

@@END_TABLE@@

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table_If <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   <B>function</B> In_Stock (Device : <B>in</B> String) <B>return</B> Boolean;
   -- <I> Complex function. Does a SQL access to the right database to know if</I>
   -- <I> the Device is available and thus can be ordered.</I>

   <B>procedure</B> Add (Device, Price : <B>in</B> String);
   -- <I> Add the device into the list to be displayed.</I>

   Devices   : Templates_Parser.Tag;
   Prices    : Templates_Parser.Tag;
   Available : Templates_Parser.Tag;

   ---------
   -- <I>Add --</I>
   ---------

   <B>procedure</B> Add (Device, Price : <B>in</B> String) <B>is</B>
   <B>begin</B>
      Devices   := Devices &#38; Device;
      Prices    := Prices &#38; Price;
      Available := Available &#38; In_Stock (Device);
   <B>end</B> Add;

   --------------
   -- <I>In_Stock --</I>
   --------------

   <B>function</B> In_Stock (Device : <B>in</B> String) <B>return</B> Boolean <B>is</B>
   <B>begin</B>
      <B>if</B> Device = "<I>Keyboard</I>" <B>then</B>
         <B>return</B> True;
      <B>else</B>
         <B>return</B> False;
      <B>end</B> <B>if</B>;
   <B>end</B> In_Stock;

   Translations : Templates_Parser.Translate_Table (1 .. 3);

<B>begin</B>
   Add ("<I>Screen</I>", "<I>$500</I>");
   Add ("<I>Keyboard</I>", "<I>$15</I>");
   Add ("<I>Mouse</I>", "<I>$15</I>");
   Add ("<I>Hard Drive</I>", "<I>$140</I>");

   Translations := (Templates_Parser.Assoc ("<I>DEVICES</I>", Devices),
                    Templates_Parser.Assoc ("<I>PRICES</I>", Prices),
                    Templates_Parser.Assoc ("<I>AVAILABLE</I>", Available));

   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table_if.tmplt</I>", Translations));
<B>end</B> Table_If;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

Hello here are a list of devices:

&#60;table&#62;
&#60;tr&#62;
&#60;th&#62;Device Name
&#60;th&#62;Price
&#60;th&#62;Order

&#60;tr&#62;
&#60;td&#62;Screen
&#60;td&#62;$500

&#60;td&#62;
Sorry, not available

&#60;tr&#62;
&#60;td&#62;Keyboard
&#60;td&#62;$15

&#60;td&#62;
&#60;a href="/order?DEVICE=Keyboard"&#62;Order

&#60;tr&#62;
&#60;td&#62;Mouse
&#60;td&#62;$15

&#60;td&#62;
Sorry, not available

&#60;tr&#62;
&#60;td&#62;Hard Drive
&#60;td&#62;$140

&#60;td&#62;
Sorry, not available


</PRE>

<P>
Table tag statements can also be used with matrix tag or more nested
tag variables. In this case, for a tag variable with N nested level,
the Nth closest enclosing <CODE>TABLE</CODE> tag statement will be used for
the corresponding indices. If there is not enough indices, the last
axis are just streamed as a single text value.

</P>
<P>
Let's see what happen for a matrix tag:

</P>

<OL>

<LI>Inside a table of level 2 (a TABLE tag statement inside a TABLE tag

statement).

In this case the first <CODE>TABLE</CODE> iterates through the matrix lines.
First iteration will use the first matrix's vector, second
iteration will use second matrix's vector and so on. And the second
<CODE>TABLE</CODE> will be use to iterate through the vector's values.

<LI>Inside a table of level 1.

In this case the <CODE>TABLE</CODE> iterates through the matrix lines. First
iteration will use the first matrix's vector, second iteration will
use second matrix's vector and so on. Each vector is then converted to
a string by concatenating all values using the specified separator
(see Assoc constructor for Tag or <CODE>Set_Separator</CODE> routine).

<LI>Outside a table statement.

In this case the matrix is converted to a string. Each line represents
a vector converted as a string using the supplied separator (see point
2 above), and each vector is separated by an ASCII.LF character. The
separators to use for each level can be specified using <CODE>Set_Separator</CODE>.

</OL>

<P>
Let's look at an example, with the following template:

</P>

<PRE>

A matrix <B>in</B>side a table <B>of</B> level 2:

@@TABLE@@
&#60;tr&#62;
@@TABLE@@
&#60;td&#62;
@_MAT_@
&#60;/td&#62;
@@END_TABLE@@
&#60;/tr&#62;

@@END_TABLE@@

The same matrix <B>in</B>side a single table:

@@TABLE@@
&#60;tr&#62;
&#60;td&#62;
@_MAT_@
&#60;/tr&#62;

@@END_TABLE@@

The same matrix <B>out</B>side a table:

@_MAT_@

</PRE>

<P>
Using the program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Matrix <B>is</B>

   <B>package</B> TP renames Templates_Parser;

   <B>use</B> <B>type</B> TP.Vector_Tag;
   <B>use</B> <B>type</B> TP.Matrix_Tag;

   V1 : <B>constant</B> TP.Vector_Tag := +"<I>A1.1</I>" &#38; "<I>A1.2</I>";
   V2 : <B>constant</B> TP.Vector_Tag := +"<I>A2.1</I>" &#38; "<I>A2.2</I>";
   V3 : <B>constant</B> TP.Vector_Tag := +"<I>A3.1</I>" &#38; "<I>A3.2</I>";

   M  : <B>constant</B> TP.Matrix_Tag := +V1 &#38; V2 &#38; V3;

<B>begin</B>
   Ada.Text_IO.Put_Line
     (TP.Parse ("<I>matrix.tmplt</I>",
                TP.Translate_Table'(1 =&#62; TP.Assoc ("<I>MAT</I>", M))));
<B>end</B> Matrix;

</PRE>

<P>
We get the following result:

</P>

<PRE>

A matrix inside a table of level 2:

&#60;tr&#62;
&#60;td&#62;
A1.1
&#60;/td&#62;
&#60;td&#62;
A1.2
&#60;/td&#62;
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A2.1
&#60;/td&#62;
&#60;td&#62;
A2.2
&#60;/td&#62;
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A3.1
&#60;/td&#62;
&#60;td&#62;
A3.2
&#60;/td&#62;
&#60;/tr&#62;


The same matrix inside a single table:

&#60;tr&#62;
&#60;td&#62;
A1.1, A1.2
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A2.1, A2.2
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A3.1, A3.2
&#60;/tr&#62;


The same matrix outside a table:

A1.1, A1.2
A2.1, A2.2
A3.1, A3.2
</PRE>



<H1><A NAME="SEC15" HREF="templates_parser.html#TOC15">Last notes</A></H1>

<P>
The templates parser has be written to parse <CODE>HTML</CODE> page but it is usable
with any king of files. There is nothing hard coded for <CODE>HTML</CODE>, it is then
possible to use it with plain text files, <CODE>XML</CODE> files, <CODE>SGML</CODE> files
or whatever as long as it is not a binary file.

</P>
<P>

<P>
All tag statements can be mixed together. A <CODE>TABLE</CODE> tag statement can be
put in an <CODE>IF</CODE> tag statement. An <CODE>IF</CODE> tag statement can be put
in a <CODE>TABLE</CODE> tag statement. Idem for the <CODE>INCLUDE</CODE> tag statement.

</P>
<P>
Download page is <A HREF="http://www.obry.org/">http://www.obry.org/</A>.

</P>
<P>



<H1><A NAME="SEC16" HREF="templates_parser.html#TOC16">Templates_Parser Ada spec</A></H1>


<PRE>

------------------------------------------------------------------------------
-- <I>                            Templates Parser                             --</I>
-- <I>                                                                         --</I>
-- <I>                       Copyright (C) 1999 - 2004                         --</I>
-- <I>                              Pascal Obry                                --</I>
-- <I>                                                                         --</I>
-- <I> This library is free software; you can redistribute it and/or modify    --</I>
-- <I> it under the terms of the GNU General Public License as published by    --</I>
-- <I> the Free Software Foundation; either version 2 of the License, or (at   --</I>
-- <I> your option) any later version.                                         --</I>
-- <I>                                                                         --</I>
-- <I> This library is distributed in the hope that it will be useful, but     --</I>
-- <I> WITHOUT ANY WARRANTY; without even the implied warranty of              --</I>
-- <I> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</I>
-- <I> General Public License for more details.                                --</I>
-- <I>                                                                         --</I>
-- <I> You should have received a copy of the GNU General Public License       --</I>
-- <I> along with this library; if not, write to the Free Software Foundation, --</I>
-- <I> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</I>
-- <I>                                                                         --</I>
-- <I> As a special exception, if other files instantiate generics from this   --</I>
-- <I> unit, or you link this unit with other files to produce an executable,  --</I>
-- <I> this  unit  does not  by itself cause  the resulting executable to be   --</I>
-- <I> covered by the GNU General Public License. This exception does not      --</I>
-- <I> however invalidate any other reasons why the executable file  might be  --</I>
-- <I> covered by the  GNU Public License.                                     --</I>
------------------------------------------------------------------------------

-- <I> $Id$</I>

<B>with</B> Ada.Finalization;
<B>with</B> Ada.Strings.Unbounded;

<B>with</B> Strings_Maps;

<B>package</B> Templates_Parser <B>is</B>

   <B>use</B> Ada.Strings.Unbounded;

   Template_Error : <B>exception</B>;

   Default_Begin_Tag : <B>constant</B> String := "<I>@_</I>";
   Default_End_Tag   : <B>constant</B> String := "<I>_@</I>";

   Default_Separator : <B>constant</B> String := "<I>, </I>";

   <B>procedure</B> Set_Tag_Separators
     (Start_With : <B>in</B> String := Default_Begin_Tag;
      Stop_With  : <B>in</B> String := Default_End_Tag);
   -- <I> Set the tag separators for the whole session. This should be changed as</I>
   -- <I> the very first API call and should not be changed after.</I>

   -----------------
   -- <I>Generic Tag --</I>
   -----------------

   <B>type</B> Tag <B>is</B> <B>private</B>;

   <B>function</B> "<I>+</I>" (Value : <B>in</B> String)           <B>return</B> Tag;
   <B>function</B> "<I>+</I>" (Value : <B>in</B> Character)        <B>return</B> Tag;
   <B>function</B> "<I>+</I>" (Value : <B>in</B> Boolean)          <B>return</B> Tag;
   <B>function</B> "<I>+</I>" (Value : <B>in</B> Unbounded_String) <B>return</B> Tag;
   <B>function</B> "<I>+</I>" (Value : <B>in</B> Integer)          <B>return</B> Tag;
   <B>function</B> "<I>+</I>" (Value : <B>in</B> Tag)              <B>return</B> Tag;
   -- <I> Tag constructors</I>

   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> String)           <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> Character)        <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> Boolean)          <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> Unbounded_String) <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> Integer)          <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (T : <B>in</B> Tag; Value : <B>in</B> Tag)              <B>return</B> Tag;
   -- <I> Add Value at the end of the tag</I>

   <B>function</B> "<I>&#38;</I>" (Value : <B>in</B> String;           T : <B>in</B> Tag) <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (Value : <B>in</B> Character;        T : <B>in</B> Tag) <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (Value : <B>in</B> Boolean;          T : <B>in</B> Tag) <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (Value : <B>in</B> Unbounded_String; T : <B>in</B> Tag) <B>return</B> Tag;
   <B>function</B> "<I>&#38;</I>" (Value : <B>in</B> Integer;          T : <B>in</B> Tag) <B>return</B> Tag;
   -- <I> Add Value at the front of the tag</I>

   <B>procedure</B> Set_Separator (T : <B>in</B> <B>out</B> Tag; Separator : <B>in</B> String);
   -- <I> Set separator to be used when building a flat representation of</I>
   -- <I> a composite tag.</I>

   <B>procedure</B> Clear (T : <B>in</B> <B>out</B> Tag);
   -- <I> Removes all values in the tag. Current tag T is not released but</I>
   -- <I> the returned object is separated (not using the same reference) than</I>
   -- <I> the original one.</I>

   <B>function</B> Size (T : <B>in</B> Tag) <B>return</B> Natural;
   -- <I> Returns the number of value into T</I>

   <B>function</B> Item (T : <B>in</B> Tag; N : <B>in</B> Positive) <B>return</B> String;
   -- <I> Returns the Nth Tag's item. Raises Constraint_Error if there is</I>
   -- <I> no such Item in T (i.e. T length &#60; N).</I>

   <B>function</B> Item (T : <B>in</B> Tag; N : <B>in</B> Positive) <B>return</B> Tag;
   -- <I> Returns the Nth Tag's item. Raises Constraint_Error if there is</I>
   -- <I> no such Item in T (i.e. T length &#60; N).</I>

   <B>subtype</B> Vector_Tag <B>is</B> Tag;
   <B>subtype</B> Matrix_Tag <B>is</B> Tag;

   ------------------
   -- <I>Associations --</I>
   ------------------

   <B>type</B> Association <B>is</B> <B>private</B>;

   <B>type</B> Association_Kind <B>is</B> (Std, Composite);
   -- <I> The kind of association which is either Std (a simple value), a vector</I>
   -- <I> tag or a Matrix tag.</I>

   <B>function</B> Assoc
     (Variable : <B>in</B> String;
      Value    : <B>in</B> String)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value is a string.</I>

   <B>function</B> Assoc
     (Variable : <B>in</B> String;
      Value    : <B>in</B> Unbounded_String)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value is an</I>
   -- <I> Unbounded_String.</I>

   <B>function</B> Assoc
     (Variable : <B>in</B> String;
      Value    : <B>in</B> Integer)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value is an Integer.</I>
   -- <I> It will be displayed without leading space if positive.</I>

   <B>function</B> Assoc
     (Variable : <B>in</B> String;
      Value    : <B>in</B> Boolean)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. It set the variable to TRUE or FALSE depending on</I>
   -- <I> value.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Tag;
      Separator : <B>in</B> String := Default_Separator)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to Translate_Table.</I>
   -- <I> This is a tag association. Separator will be used when outputting the</I>
   -- <I> a flat representation of the Tag (outside a table statement).</I>

   ---------------------------
   -- <I>Association table/set --</I>
   ---------------------------

   <B>type</B> Translate_Table <B>is</B> <B>array</B> (Positive <B>range</B> &#60;&#62;) <B>of</B> Association;
   -- <I> A table with a set of associations, note that it is better to use</I>
   -- <I> Translate_Set below as it is more efficient.</I>

   No_Translation : <B>constant</B> Translate_Table;

   <B>type</B> Translate_Set <B>is</B> <B>private</B>;
   -- <I> This is a set of association like Translate_Table but it is possible to</I>
   -- <I> insert item into this set more easily, furthermore there is no need to</I>
   -- <I> know the number of item before hand. This is the object used internally</I>
   -- <I> by the templates engine as it is far more efficient to retrieve a</I>
   -- <I> specific item from it.</I>

   <B>procedure</B> Insert (Set : <B>in</B> <B>out</B> Translate_Set; Item : <B>in</B> Association);
   -- <I> Add Item into the translate set. If an association for this variable</I>
   -- <I> already exist it just replaces it by the new item.</I>

   <B>function</B> Exists
     (Set      : <B>in</B> Translate_Set;
      Variable : <B>in</B> String) <B>return</B> Boolean;
   -- <I> Returns True if an association for Variable exists into the Set</I>

   <B>function</B> To_Set (Table : <B>in</B> Translate_Table) <B>return</B> Translate_Set;
   -- <I> Convert a Translate_Table into a Translate_Set</I>

   -----------------------------
   -- <I>Parsing and Translating --</I>
   -----------------------------

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Table := No_Translation;
      Cached            : <B>in</B> Boolean         := False;
      Keep_Unknown_Tags : <B>in</B> Boolean         := False)
      <B>return</B> String;
   -- <I> Parse the Template_File replacing variables' occurrences by the</I>
   -- <I> corresponding values. If Cached is set to True, Filename tree will be</I>
   -- <I> recorded into a cache for quick retrieval. If Keep_Unknown_Tags is set</I>
   -- <I> to True then tags that are not in the translate table are kept</I>
   -- <I> as-is if it is part of the template data. If this tags is part of a</I>
   -- <I> condition (in an IF statement tag), the condition will evaluate to</I>
   -- <I> False.</I>

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Table := No_Translation;
      Cached            : <B>in</B> Boolean         := False;
      Keep_Unknown_Tags : <B>in</B> Boolean         := False)
      <B>return</B> Unbounded_String;
   -- <I> Idem but returns an Unbounded_String</I>

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Set;
      Cached            : <B>in</B> Boolean       := False;
      Keep_Unknown_Tags : <B>in</B> Boolean       := False)
      <B>return</B> String;
   -- <I> Idem with a Translation_Set</I>

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Set;
      Cached            : <B>in</B> Boolean       := False;
      Keep_Unknown_Tags : <B>in</B> Boolean       := False)
      <B>return</B> Unbounded_String;
   -- <I> Idem with a Translation_Set</I>

   <B>function</B> Translate
     (Template     : <B>in</B> String;
      Translations : <B>in</B> Translate_Table := No_Translation)
      <B>return</B> String;
   -- <I> Just translate the discrete variables in the Template string using the</I>
   -- <I> Translations table. This function does not parse the command tag (TABLE,</I>
   -- <I> IF, INCLUDE). All composite tags are replaced by the empty string.</I>

   <B>function</B> Translate
     (Template     : <B>in</B> String;
      Translations : <B>in</B> Translate_Set)
      <B>return</B> String;
   -- <I> Idem with a Translation_Set</I>

<B>private</B>
   -- <I> implementation removed</I>
<B>end</B> Templates_Parser;

</PRE>

<P><HR><P>
This document was generated on 12 May 2004 using the
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>
translator version 1.52.</P>
</BODY>
</HTML>
