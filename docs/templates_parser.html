<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from templates_parser.texi on 29 November 2003 -->

<TITLE>Templates Parser</TITLE>
</HEAD>
<BODY>
<H1>Templates Parser</H1>
<H2>$Revision$</H2>
<H2>Date: 29 November 2003</H2>
<ADDRESS>Pascal Obry (<A HREF="mailto:p.obry@wanadoo.fr">p.obry@wanadoo.fr</A>)</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="templates_parser.html#SEC1">Introduction</A>
<LI><A NAME="TOC2" HREF="templates_parser.html#SEC2">What is a tag ?</A>
<LI><A NAME="TOC3" HREF="templates_parser.html#SEC3">Variable tags</A>
<UL>
<LI><A NAME="TOC4" HREF="templates_parser.html#SEC4">Discrete, Boolean, Vector and Matrix</A>
<LI><A NAME="TOC5" HREF="templates_parser.html#SEC5">Filters and Attributes</A>
<UL>
<LI><A NAME="TOC6" HREF="templates_parser.html#SEC6">Filters</A>
<LI><A NAME="TOC7" HREF="templates_parser.html#SEC7">Attributes</A>
</UL>
<LI><A NAME="TOC8" HREF="templates_parser.html#SEC8">Other variables tags</A>
</UL>
<LI><A NAME="TOC9" HREF="templates_parser.html#SEC9">Tag statements</A>
<UL>
<LI><A NAME="TOC10" HREF="templates_parser.html#SEC10">Comments tag statement</A>
<LI><A NAME="TOC11" HREF="templates_parser.html#SEC11">INCLUDE tag statement</A>
<LI><A NAME="TOC12" HREF="templates_parser.html#SEC12">IF tag statement</A>
<LI><A NAME="TOC13" HREF="templates_parser.html#SEC13">TABLE tag statement</A>
</UL>
<LI><A NAME="TOC14" HREF="templates_parser.html#SEC14">Last notes</A>
<LI><A NAME="TOC15" HREF="templates_parser.html#SEC15">Templates_Parser Ada spec</A>
</UL>
<P><HR><P>



<H1><A NAME="SEC1" HREF="templates_parser.html#TOC1">Introduction</A></H1>

<P>
First of all this package is distributed under the GNAT modified GNU GPL.

</P>
<P>
The templates parser package has been designed to parse files and to
replace some specific tags into these files by some specified values.

</P>
<P>
The main goal was to ease the development of Web servers. In CGI 
(<I>Common Gateway Interface</I>) mode you have to write the HTML page in
the program (in Ada or whatever other languages) by using some specific
libraries or by using only basic output functions like Ada <CODE>Put_Line</CODE> for
example. This is of course not mandatory but by lack of a good library
every Web development end up doing just that.

</P>
<P>
The main problems with this approach are:

</P>

<UL>

<LI>It is painful to have to recompile the program each time you have

a slight change to do in the design (center an image, change the border
width of a table...)

<LI>You have the design and the program merged together. It means that

to change the design you must know the Ada language. And to change the
Ada program you need to understand what is going on with all these
inline HTML command.

<LI>You can't use the nice tools to generate your HTML.

</UL>

<P>
With the templates parser package these problems are gone. The code and
the design is <B>completely</B> separated. This is a very important
point. PHP or JSP have tried this but most of the time you have the
script embedded into the Web template. And worst you need to use another
language just for your Web development.

</P>

<UL>

<LI>The HTML page is separated from the program code. Then you can

change the design without changing the code. Moreover when you fix the
code you don't have to handle all the specific HTML output. And you do
not risk to break the design.

<LI>It is easier to work on the design and the program at the same time

using the right peoples for the job.

<LI>It reduce the number of <I>edit/build/test</I> cycles. Writing HTML

code from a program is error prone.

<LI>It is possible to use standard tools to produce the HTML.

<LI>You don't have to learn a new language.

<LI>The script is Ada, so here you have the benefit of all the Ada power.

</UL>

<P>
In fact, now the Ada program just compute some values, get some data
from a database or whatever and then call the templates parser to output
a page with the data displayed. To the templates parser you just pass
the template filename and an associative table. 

</P>
<P>
It is even more convenient to have different display with the same set
of data. You just have to provides as many templates as you like.

</P>



<H1><A NAME="SEC2" HREF="templates_parser.html#TOC2">What is a tag ?</A></H1>

<P>
A tag is a string found in the template page and surrounded by a specific set
of characters. The default is <B>@_</B> at the start and <B>_@</B> at the
end of the tag. This default can be changed using <CODE>Set_Tag_Separators</CODE>
routine, see section <A HREF="templates_parser.html#SEC15">Templates_Parser Ada spec</A>. Note that it must be changed
as the first API call and should not be changed after that.

</P>
<P>
The tag will be replaced by a value specified in a translation table.

</P>
<P>
For example with the template file <TT>`demo.tmplt'</TT>:

</P>

<PRE>

&#60;P&#62;Name @_NAME_@

</PRE>

<P>
Using the following code <TT>`demo.adb'</TT>:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Demo <B>is</B>

   Translations : Templates_Parser.Translate_Table :=
     (1 =&#62; Templates_Parser.Assoc ("<I>NAME</I>", "<I>Ada</I>"));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>demo.tmplt</I>", Translations));
<B>end</B> Demo;

</PRE>

<P>
The program will print out :

</P>

<PRE>
&#60;P&#62;Name Ada
</PRE>

<P>
This is a very simple example, but you'll see that there is a lot of
powerful construct that you can use into a template file.

</P>



<H1><A NAME="SEC3" HREF="templates_parser.html#TOC3">Variable tags</A></H1>


<UL>
<LI><A HREF="templates_parser.html#SEC4">Discrete Boolean Vector and Matrix</A>
<LI><A HREF="templates_parser.html#SEC5">Filters and Attributes</A>
<LI><A HREF="templates_parser.html#SEC8">Other variables tags</A>
</UL>



<H2><A NAME="SEC4" HREF="templates_parser.html#TOC4">Discrete, Boolean, Vector and Matrix</A></H2>

<P>
A variable tag is a specific string to be replaced by the template
parser. There is four kinds of variable tags: <B>discrete</B>, <B>boolean</B>,
<B>vector</B> and <B>matrix</B>. All variables tags are build using the Assoc
constructors, see section <A HREF="templates_parser.html#SEC15">Templates_Parser Ada spec</A>.

</P>
<DL COMPACT>

<DT><CODE>discrete</CODE>
<DD>
We have already seen the discrete variable tag. This is a variable which
has only one value. This value will replace the tag in the template
file. Discrete variable constructors are provided for String,
Unbounded_String and Integer (see Assoc routines).

<DT><CODE>boolean</CODE>
<DD>
A boolean tag as a value of TRUE or FALSE. This value will replace the
tag in the template file. These tags can also be used with the IF tag
statement.

<DT><CODE>vector</CODE>
<DD>
A vector tag is a variable which represent a set of values. These kind of
variables will be used with the TABLE tag statement 
see section <A HREF="templates_parser.html#SEC13">TABLE tag statement</A>. Outside a table statement it will be
replaced by all values in the vector tag.

There is many overloaded constructors to build vector tags (see "+"
operators).  The "+" operators are used to build a Vector_Tag item from
standards types like String, Unbounded_String, Character, Integer and
Boolean. 

To add items to a vector tag many overloaded operators are provided (see
"&#38;" operators). The "&#38;" operators add one item at the end of the vector,
it is possible to add directly String, Unbounded_String, Character,
Integer and Boolean items using one of the overloaded operator.

A Vector tag composed of only boolean value TRUE or FALSE is called a
Boolean Vector tag. This tag is to be used with a IF tag statement
inside a TABLE tag statement.

<DT><CODE>matrix</CODE>
<DD>
A matrix tag is a variable which represent a set of vector tags. These
kind of variables will be used inside a TABLE tag statement embedded
into another TABLE tag statement (i.e. a TABLE tag statement of level 2).

A matrix variable tag is built by concatenating vector variables.

</DL>



<H2><A NAME="SEC5" HREF="templates_parser.html#TOC5">Filters and Attributes</A></H2>

<P>
All kinds of variable tag can have one or more function-prefix or filter. The
function prefix is applied to the variable value. The syntax is
<CODE>@_[[FILTER_NAME[(parameter)]:]FILTER_NAME[(parameter)]:]SOME_VAR_@</CODE>.
Filters are evaluated from right to left.

</P>
<P>
Vector and Matrix tag can also have attributes. Attributes are placed
after the tag name and preceded with a simple quote.
<CODE>@_SOME_VAR['ATTRIBUTE_NAME]_@</CODE>. It is possible to use filters
and attributes together. In that case the attribute is first evaluated and
the result is passed-through the filters.

</P>

<UL>
<LI><A HREF="templates_parser.html#SEC6">Filters</A>
<LI><A HREF="templates_parser.html#SEC7">Attributes</A>
</UL>



<H3><A NAME="SEC6" HREF="templates_parser.html#TOC6">Filters</A></H3>

<P>
The current supported filters are:

</P>
<DL COMPACT>

<DT><CODE>"+"(<I>N</I>) or ADD(<I>N</I>)</CODE>
<DD>
Add N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number.

<DT><CODE>"-"(<I>N</I>) or SUB(<I>N</I>)</CODE>
<DD>
Subtract N to variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number.

<DT><CODE>"*"(<I>N</I>) or MULT(<I>N</I>)</CODE>
<DD>
Multiply N with variable and return the result. If the current variable value
is not a number it returns the empty string. N must be a number.

<DT><CODE>"/"(<I>N</I>) or DIV(<I>N</I>)</CODE>
<DD>
Divide variable by N and return the result. If the current variable value
is not a number it returns the empty string. N must be a number.

<DT><CODE>BR_2_LF</CODE>
<DD>
Replaces all occurrences of the <CODE>&#60;br&#62;</CODE> HTML tag by a LF
(Line-Feed) character.

<DT><CODE>CAPITALIZE</CODE>
<DD>
Put all characters in the variable in lower case except characters after
a space or an underscore which are set in upper-case.

<DT><CODE>CLEAN_TEXT</CODE>
<DD>
Keep only letters and digits all others characters are changed to
spaces.

<DT><CODE>COMA_2_POINT</CODE>
<DD>
Replaces all comas by points.

<DT><CODE>CONTRACT</CODE>
<DD>
Converts any suite of spaces by a single space character.

<DT><CODE>EXIST</CODE>
<DD>
Returns <B>True</B> if variable is set and has a value different that the null
string and <B>False</B> otherwise.

<DT><CODE>FORMAT_NUMBER</CODE>
<DD>
Returns the number with a space added between each 3 digits
blocks. The decimal part is not transformed. If the data is not a
number nothing is done.

<DT><CODE>IS_EMPTY</CODE>
<DD>
Returns <B>True</B> if variable is the empty string and <B>False</B> otherwise.

<DT><CODE>LF_2_BR</CODE>
<DD>
Replaces all occurrences of the character LF (Line-Feed) by a
<CODE>&#60;br&#62;</CODE> HTML tag.

<DT><CODE>LOWER</CODE>
<DD>
Put all characters in the variable in lower-case.

<DT><CODE>MATCH(<I>REGEXP</I>)</CODE>
<DD>
Returns <B>True</B> if variable match the regular expression passed as
filter's parameter. The regular expression is using a format as
found in <TT>`gawk'</TT>, <TT>`sed'</TT> or <TT>`grep'</TT> tools.

<DT><CODE>MOD(<I>N</I>)</CODE>
<DD>
Returns variable modulo N. If the current variable value is not a
number it returns the empty string. N must be a number.

<DT><CODE>NO_DIGIT</CODE>
<DD>
Replaces all digits by spaces.

<DT><CODE>NO_LETTER</CODE>
<DD>
Replaces all letters by spaces.

<DT><CODE>NO_SPACE</CODE>
<DD>
Removes all spaces in the variable.

<DT><CODE>OUI_NON</CODE>
<DD>
If variable value is <B>True</B> it returns <B>Oui</B>, if <B>False</B> it
returns <B>Non</B>, otherwise does nothing. It keeps the way <B>True/False</B> is
capitalized (all upper, all lower or first letter capital).

<DT><CODE>POINT_2_COMA</CODE>
<DD>
Replaces all comas by points.

<DT><CODE>REPEAT(<I>N</I>)</CODE>
<DD>
Returns N times the variable, N being passed as filter's parameter.

<DT><CODE>REPLACE(<I>REGEXP</I>[/<I>STR</I>])</CODE>
<DD>
This filter replaces <B>\n</B> (where <I>n</I> is a number) <I>STR</I>'s
occurences by the corresponding match from <I>REGEXP</I>. The first match
in <I>REGEXP</I> will replace <B>\1</B>, the second match <B>\2</B> and so
on. Each match in <I>REGEXP</I> must be parenthesized. <I>STR</I> is an optional
parameter, its default value is <B>\1</B>.

<DT><CODE>REVERSE</CODE>
<DD>
Reverse the string.

<DT><CODE>SIZE</CODE>
<DD>
Returns the size (number of characters) of the string value.

<DT><CODE>SLICE(<I>x .. y</I>)</CODE>
<DD>
Returns the sub-string starting from position x and ending to position
y. Note that the string to slice always start from position 1.

<DT><CODE>TRIM</CODE>
<DD>
Removes leading and trailing spaces.

<DT><CODE>UPPER</CODE>
<DD>
Put all characters in the variable in upper-case.

<DT><CODE>WEB_ESCAPE</CODE>
<DD>
Replaces characters '&#60;', '&#62;', '"' and '&#38;' by corresponding HTML
sequences: &#38;lt; &#38;gt; &#38;quot; and &#38;amp; 

<DT><CODE>WEB_NBSP</CODE>
<DD>
Replaces all spaces by an HTML non breaking space.

<DT><CODE>YES_NO</CODE>
<DD>
If variable value is <B>True</B> it returns <B>Yes</B>, if <B>False</B> it
returns <B>No</B>, otherwise does nothing. It keeps the way <B>True/False</B> is
capitalized (all upper, all lower or first letter capital).

</DL>

<P>
For example:

</P>

<PRE>
If VAR is set to "<I>vector_tag</I>" then:

@_VAR_@                                   -&#62;  vector_tag
@_UPPER:VAR_@                             -&#62;  VECTOR_TAG
@_CAPITALIZE:VAR_@                        -&#62;  Vector_Tag
@_EXIST:VAR_@                             -&#62;  TRUE
@_UPPER:REVERSE:VAR_@                     -&#62;  GAT_ROTCEV
@_MATCH(VEC.*):UPPER:VAR_@                -&#62;  TRUE
@_SLICE(1..6):VAR_@                       -&#62;  vector
@_REPLACE(([^_]+)):VAR_@                  -&#62;  vector
@_REPLACE(([a-z]+)_([a-z]+)/\2_\1):VAR_@  -&#62;  tag_vector
</PRE>



<H3><A NAME="SEC7" HREF="templates_parser.html#TOC7">Attributes</A></H3>

<P>
Current supported attributes are:

</P>
<DL COMPACT>

<DT><CODE>V'length</CODE>
<DD>
Returns the number of item in the vector.

<DT><CODE>M'Line</CODE>
<DD>
Returns the number of line in the matrix.

<DT><CODE>M'Min_Column</CODE>
<DD>
Returns the size of smallest vector in the matrix.

<DT><CODE>M'Max_Column</CODE>
<DD>
Returns the size of largest vector in the matrix.

</DL>

<P>
For example:

</P>

<PRE>
If VEC is set to "<I>&#60;1 , 2&#62;</I>" and MAT to "<I>&#60;a, b, c&#62; ; &#60;2, 3, 5, 7&#62;</I>" then:

@_VEC'Length_@              -&#62;  2
@_ADD(3):VEC'Length_@       -&#62;  5
@_MAT'Line_@                -&#62;  2
@_MAT'Min_Column_@          -&#62;  3
@_MAT'Max_Column_@          -&#62;  4

</PRE>



<H2><A NAME="SEC8" HREF="templates_parser.html#TOC8">Other variables tags</A></H2>

<P>
There is some specific variables tags that can be used in any
templates. Here is a description of them:

</P>
<DL COMPACT>

<DT><CODE>YEAR</CODE>
<DD>
Current year number using 4 digits.

<DT><CODE>MONTH</CODE>
<DD>
Current month number using 2 digits.

<DT><CODE>DAY</CODE>
<DD>
Current day number using 2 digits.

<DT><CODE>HOUR</CODE>
<DD>
Current hour using range 0 to 23 using 2 digits.

<DT><CODE>MINUTE</CODE>
<DD>
Current minute using 2 digits.

<DT><CODE>SECOND</CODE>
<DD>
Current seconds using 2 digits.

<DT><CODE>MONTH_NAME</CODE>
<DD>
Current full month name (January .. December).

<DT><CODE>DAY_NAME</CODE>
<DD>
Current full day name (Monday .. Sunday).

</DL>



<H1><A NAME="SEC9" HREF="templates_parser.html#TOC9">Tag statements</A></H1>

<P>
There is three different tag statements. A tag statement is surrounded
by <CODE>@@</CODE>. The tag statements are:

</P>

<UL>
<LI><A HREF="templates_parser.html#SEC10">Comments tag statement</A>
<LI><A HREF="templates_parser.html#SEC11">INCLUDE tag statement</A>
<LI><A HREF="templates_parser.html#SEC12">IF tag statement</A>
<LI><A HREF="templates_parser.html#SEC13">TABLE tag statement</A>
</UL>



<H2><A NAME="SEC10" HREF="templates_parser.html#TOC10">Comments tag statement</A></H2>

<P>
Every line starting with <B>@@--</B> are comments and are completly
ignored by the parser. The resulting page will have the exact same
format and number of lines with or without the comments.

</P>

<PRE>
@@-- This template is used to display the client's data
@@-- It uses the following tags:
@@--
@@--    @_CID_@       Client ID
@@--    @_ITEMS_V_@   List of items (vector tag)

&#60;P&#62;Client @_CID_@

...
</PRE>



<H2><A NAME="SEC11" HREF="templates_parser.html#TOC11">INCLUDE tag statement</A></H2>

<P>
This tag is used to include another template file. This is useful if you
have the same header and/or footer in all your HTML pages. For example:

</P>

<PRE>
@@INCLUDE@@ header.tmplt

&#60;P&#62;This is by Web page

@@INCLUDE@@ footer.tmplt
</PRE>

<P>
It is also possible to pass arguments to the include file. These parameters
are put after the include filename. It is possible to reference these
parameters into the included file with the special variable names
<CODE>@_$&#60;n&#62;_@</CODE>, where <I>n</I> is the include's parameter indice (0 is
the include filename, 1 the first parameter and so on).

</P>

<PRE>
@@INCLUDE@@ another.tmplt @_VAR_@ azerty
</PRE>

<P>
In file <TT>`another.tmplt'</TT>

</P>
<DL COMPACT>

<DT><CODE>@_$0_@</CODE>
<DD>
is another.tmplt
<DT><CODE>@_$1_@</CODE>
<DD>
is the variable @_VAR_@
<DT><CODE>@_$2_@</CODE>
<DD>
is the string "azerty"
</DL>

<P>
If an include variable references a non existing include parameter the
tag is kept as-is.

</P>


<H2><A NAME="SEC12" HREF="templates_parser.html#TOC12">IF tag statement</A></H2>

<P>
This is the conditional tag statement. The complete form is:

</P>

<PRE>
@@IF@@ &#60;expression1&#62;
   part1
@@ELSIF@@ &#60;expression2&#62;
   part2
@@ELSE@@
   part3
@@END_IF@@
</PRE>

<P>
The part1 one will be parsed if expression1 evaluate to "TRUE", part2
will be parsed if expression2 evaluate to "TRUE" and the part3 will
be parse in any other case. The ELSIF and ELSE part are optional.

</P>
<P>
The expression here is composed of boolean variable (or conditional
variable) and/or boolean expression. Recognized operators are:

</P>
<DL COMPACT>

<DT><CODE>A = B</CODE>
<DD>
Returns TRUE if A equal B

<DT><CODE>A /= B</CODE>
<DD>
Returns TRUE if A is not equal B

<DT><CODE>A &#62; B</CODE>
<DD>
Returns TRUE if A greater than B. If A and B are numbers it returns the
the number comparison (5 &#62; 003 = TRUE) otherwise it returns the string
comparison ("5" &#62; "003" = FALSE).

<DT><CODE>A &#62;= B</CODE>
<DD>
Returns TRUE if A greater than or equal to B. See above for rule about numbers.

<DT><CODE>A &#60; B</CODE>
<DD>
Returns TRUE if A lesser than B. See above for rule about numbers.

<DT><CODE>A &#60;= B</CODE>
<DD>
Returns TRUE if A lesser than or equal to B. See above for rule about numbers.

<DT><CODE>A and B</CODE>
<DD>
Returns TRUE if A and B is TRUE and FALSE otherwise.

<DT><CODE>A or B</CODE>
<DD>
Returns TRUE if A or B is TRUE and FALSE otherwise.

<DT><CODE>A xor B</CODE>
<DD>
Returns TRUE if either A or B (but not both) is TRUE and FALSE otherwise.

<DT><CODE>not A</CODE>
<DD>
Returns TRUE if either A is FALSE and FALSE otherwise.
</DL>

<P>
The default evaluation order is done from left to right, all operators
having the same precedence. To build an expression it is possible to
use the parentheses to change the evaluation order. A value with
spaces must be quoted as a string. So valid expressions could be:

</P>

<PRE>
@@IF@@ (@_VAR1_@ &#62; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ not (@_VAR1_@ &#62; 3) or (@_COND1_@ and @_COND2_@)

@@IF@@ (@_VAR1_@ &#62; 3) and not @_COND1_@

@@IF@@ @_VAR1_@ = "a value"
</PRE>

<P>
Note also that variables and values can be surrounded by quotes if needed.
Quotes are needed if a value contain spaces.

</P>
<P>
To generate a conditional variable tag it is possible to use the
following <B>Templates_Parser</B> function:

</P>

<PRE>
<B>function</B> Assoc (Variable  : <B>in</B> String;
                Value     : <B>in</B> Boolean;
                <B>return</B> Association;
<I>--  build an Association (Variable = Value) to be added to a</I>
<I>--  Translate_Table. It set the variable to TRUE or FALSE depending on</I>
<I>--  Value.</I>
</PRE>

<P>
Let's see an example using an IF tag statement. With the following
template:

</P>

<PRE>

@@IF@@ @_USER_@
   &#60;P&#62;As a <B>use</B>r you have a restricted access to this server.
@@ELSE@@
   &#60;P&#62;As an administrator you have full access to this server.
@@END_IF@@

</PRE>

<P>
The following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> User1 <B>is</B>

   Translations : Templates_Parser.Translate_Table :=
     (1 =&#62; Templates_Parser.Assoc ("<I>USER</I>", True));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>user.tmplt</I>", Translations));
<B>end</B> User1;

</PRE>

<P>
Will display:

</P>

<PRE>
   &#60;P&#62;As a user you have a restricted access to this server.

</PRE>

<P>
But the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> User2 <B>is</B>

   Translations : Templates_Parser.Translate_Table :=
     (1 =&#62; Templates_Parser.Assoc ("<I>USER</I>", False));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>user.tmplt</I>", Translations));
<B>end</B> User2;

</PRE>

<P>
Will display:

</P>

<PRE>
   &#60;P&#62;As an administrator you have full access to this server.

</PRE>



<H2><A NAME="SEC13" HREF="templates_parser.html#TOC13">TABLE tag statement</A></H2>

<P>
A table tag is useful to generate HTML table for example. Basically the
code between the <CODE>@@TABLE@@</CODE> and <CODE>@@END_TABLE@@</CODE> will
be repeated as many time as the vector tag will have of values. If many
vector tags are specified in a table statement, the code between the
table will be repeated a number of time equal to the maximum length of
all vector tags in the table tag statement.

</P>
<P>
A table tag statement is a kind of implicit iterator. This is a very
important concept to build HTML table. Using <CODE>Vector_Tag</CODE> or
<CODE>Matrix_Tag</CODE> variable in a <CODE>@@TABLE@@</CODE> tag statement it is
possible to build very complex Web pages.

</P>
<P>
Syntax:

</P>

<PRE>
@@TABLE@@ [@@TERMINATE_SECTIONS@@]
   ...
[@@SECTION@@]
   ...
@@END_TABLE@@
</PRE>

<P>
Let's have an example. With the following template:

</P>

<PRE>

&#60;P&#62;Here <B>is</B> the ages <B>of</B> some peoples:

&#60;TABLE&#62;
@@TABLE@@
   &#60;TR&#62;
   &#60;TD&#62;@_NAME_@
   &#60;TD&#62;@_AGE_@
@@END_TABLE@@
&#60;/TABLE&#62;

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   Names : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>Bob</I>" &#38; "<I>Bill</I>" &#38; "<I>Toto</I>";
   Ages  : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>10</I>" &#38; "<I>30</I>" &#38; "<I>5</I>";

   Translations : Templates_Parser.Translate_Table :=
     (1 =&#62; Templates_Parser.Assoc ("<I>NAME</I>", Names),
      2 =&#62; Templates_Parser.Assoc ("<I>AGE</I>", Ages));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table.tmplt</I>", Translations));
<B>end</B> Table;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

&#60;P&#62;Here is the ages of some peoples:

&#60;TABLE&#62;
   &#60;TR&#62;
   &#60;TD&#62;Bob
   &#60;TD&#62;10
   &#60;TR&#62;
   &#60;TD&#62;Bill
   &#60;TD&#62;30
   &#60;TR&#62;
   &#60;TD&#62;Toto
   &#60;TD&#62;5
&#60;/TABLE&#62;
</PRE>

<P>
Note that we use vector tag variables here. A discrete variable tag in a table
will be replaced by the same (the only one) value for each row. A vector
tag outside a table will be displayed as a list of values, each value
being separated by a specified string. The default is a comma and a
space ", ".

</P>
<P>
The complete prototype for the <CODE>Vector_Tag</CODE> Assoc function is:

</P>

<PRE>
   <B>function</B> Assoc (Variable  : <B>in</B> String;
                   Value     : <B>in</B> Vector_Tag;
                   Separator : <B>in</B> String    := Default_Separator;
                   <B>return</B> Association;
<I>--  build an Association (Variable = Value) to be added to a</I>
<I>--  Translate_Table. This is a vector tag association, value is a</I>
<I>--  Vector_Tag. If the vector tag is found outside a table tag statement</I>
<I>--  it is returned as a single string, each value being separated by the</I>
<I>--  specified separator.</I>
</PRE>

<P>
A table can contain many sections. The section to use will be selected
depending on the current line. For example, a table with two sections
will use different data on even and odd lines. This is useful, for
example, when you want to alternate the line background color for a
better lisibility when working on HTML pages.

</P>
<P>
A table with sections can have the modifier
<CODE>@@TERMINATE_SECTIONS@@</CODE>. This ensure that the table output will end
with the last section. If the number of data in the vector variable tag
is not a multiple of the number of sections then the remaining section
will be complete with empty tag value.

</P>

<PRE>

&#60;P&#62;Here are some available computer devices:

&#60;TABLE&#62;
@@TABLE@@
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;@_DEVICES_@
   &#60;TD&#62;@_PRICES_@
@@SECTION@@
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;@_DEVICES_@
   &#60;TD&#62;@_PRICES_@
@@END_TABLE@@
&#60;/TABLE&#62;

&#60;TABLE&#62;
@@TABLE@@ @@TERMINATE_SECTIONS@@
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;@_DEVICES_@
@@SECTION@@
   &#60;TD WIDTH=150&#62;@_DEVICES_@
@@SECTION@@
   &#60;TD WIDTH=150&#62;@_DEVICES_@
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
@@END_TABLE@@
&#60;/TABLE&#62;

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table_Section <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   Devices : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>Screen</I>" &#38; "<I>Keyboard</I>" &#38; "<I>Mouse</I>" &#38; "<I>Hard Drive</I>";
   Prices  : <B>constant</B> Templates_Parser.Vector_Tag
     := +"<I>$500</I>" &#38; "<I>$20</I>" &#38; "<I>$15</I>" &#38; "<I>$140</I>";

   Translations : Templates_Parser.Translate_Table :=
     (1 =&#62; Templates_Parser.Assoc ("<I>DEVICES</I>", Devices),
      2 =&#62; Templates_Parser.Assoc ("<I>PRICES</I>", Prices));

<B>begin</B>
   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table_section.tmplt</I>", Translations));
<B>end</B> Table_Section;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

&#60;P&#62;Here are some available computer devices:

&#60;TABLE&#62;
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;Screen
   &#60;TD&#62;$500
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;Keyboard
   &#60;TD&#62;$20
   &#60;TR BGCOLOR=#F00&#62;
   &#60;TD&#62;Mouse
   &#60;TD&#62;$15
   &#60;TR BGCOLOR=#00F&#62;
   &#60;TD&#62;Hard Drive
   &#60;TD&#62;$140
&#60;/TABLE&#62;

&#60;TABLE&#62;
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;Screen
   &#60;TD WIDTH=150&#62;Keyboard
   &#60;TD WIDTH=150&#62;Mouse
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TR&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
   &#60;TD WIDTH=150&#62;Hard Drive
   &#60;TD WIDTH=150&#62;
   &#60;TD WIDTH=150&#62;
   &#60;TD BGCOLOR=#00F WIDTH=10&#62;
&#60;/TABLE&#62;
</PRE>

<P>
Into a table construct there are some additional variable tags available:

</P>
<DL COMPACT>

<DT><CODE>@_UP_TABLE_LINE_@</CODE>
<DD>
This tag will be replaced by the table line number of the upper table
statement. It will be set to 0 outside a table statement or inside a
single table statement.

<DT><CODE>@_TABLE_LINE_@</CODE>
<DD>
This tag will be replaced by the current table line number. It will be
replaced by 0 outside a table statement.

<DT><CODE>@_NUMBER_LINE_@</CODE>
<DD>
This is the number of line displayed in the table. It will be replaced
by 0 outside a table statement.

<DT><CODE>@_TABLE_LEVEL_@</CODE>
<DD>
This is the table level number. A table construct declared in a table
has a level value of 2.  It will be replaced by 0 outside a table statement.

</DL>

<P>
Let's have a look at a more complex example with mixed IF and TABLE tag
statement.

</P>
<P>
Here is the template:

</P>

<PRE>

Hello here are a list <B>of</B> devices:

&#60;table&#62;
&#60;tr&#62;
&#60;th&#62;Device Name
&#60;th&#62;Price
&#60;th&#62;Order

@@TABLE@@
&#60;tr&#62;
&#60;td&#62;@_DEVICES_@
&#60;td&#62;@_PRICES_@

&#60;td&#62;
@@IF@@ @_AVAILABLE_@
&#60;a href="<I>/order?DEVICE=@_DEVICES_@</I>"&#62;Order
@@ELSE@@
Sorry, not available
@@END_IF@@

@@END_TABLE@@

</PRE>

<P>
And the following program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Table_If <B>is</B>

   <B>use</B> <B>type</B> Templates_Parser.Vector_Tag;

   <B>function</B> In_Stock (Device : <B>in</B> String) <B>return</B> Boolean;
   -- <I> Complex <B>function</B>. Does a SQL access to the right database to know if</I>
   -- <I> the Device <B>is</B> available and thus can be ordered.</I>

   <B>procedure</B> Add (Device, Price : <B>in</B> String);
   -- <I> Add the device <B>in</B>to the list to be displayed.</I>

   Devices   : Templates_Parser.Vector_Tag;
   Prices    : Templates_Parser.Vector_Tag;
   Available : Templates_Parser.Vector_Tag;

   ---------
   -- <I>Add --</I>
   ---------

   <B>procedure</B> Add (Device, Price : <B>in</B> String) <B>is</B>
   <B>begin</B>
      Devices := Devices &#38; Device;
      Prices  := Prices &#38; Price;
      Available := Available &#38; In_Stock (Device);
   <B>end</B> Add;

   --------------
   -- <I>In_Stock --</I>
   --------------

   <B>function</B> In_Stock (Device : <B>in</B> String) <B>return</B> Boolean <B>is</B>
   <B>begin</B>
      if Device = "<I>Keyboard</I>" then
         <B>return</B> True;
      else
         <B>return</B> False;
      <B>end</B> if;
   <B>end</B> In_Stock;

   Translations : Templates_Parser.Translate_Table (1 .. 3);

<B>begin</B>
   Add ("<I>Screen</I>", "<I>$500</I>");
   Add ("<I>Keyboard</I>", "<I>$15</I>");
   Add ("<I>Mouse</I>", "<I>$15</I>");
   Add ("<I>Hard Drive</I>", "<I>$140</I>");

   Translations := (Templates_Parser.Assoc ("<I>DEVICES</I>", Devices),
                    Templates_Parser.Assoc ("<I>PRICES</I>", Prices),
                    Templates_Parser.Assoc ("<I>AVAILABLE</I>", Available));

   Ada.Text_IO.Put_Line
     (Templates_Parser.Parse ("<I>table_if.tmplt</I>", Translations));
<B>end</B> Table_If;

</PRE>

<P>
The following output will be generated:

</P>

<PRE>

Hello here are a list of devices:

&#60;table&#62;
&#60;tr&#62;
&#60;th&#62;Device Name
&#60;th&#62;Price
&#60;th&#62;Order

&#60;tr&#62;
&#60;td&#62;Screen
&#60;td&#62;$500

&#60;td&#62;
Sorry, not available

&#60;tr&#62;
&#60;td&#62;Keyboard
&#60;td&#62;$15

&#60;td&#62;
&#60;a href="/order?DEVICE=Keyboard"&#62;Order

&#60;tr&#62;
&#60;td&#62;Mouse
&#60;td&#62;$15

&#60;td&#62;
Sorry, not available

&#60;tr&#62;
&#60;td&#62;Hard Drive
&#60;td&#62;$140

&#60;td&#62;
Sorry, not available


</PRE>

<P>
Table tag statement can also be used with matrix tag. There is 3
possibles placements for a matrix tag:

</P>

<OL>

<LI>Inside a table of level 2 (a TABLE tag statement inside a TABLE tag

statement).

In this case the first TABLE iterate through the matrix lines.
First iteration will use the first matrix's vector, second
iteration will use second matrix's vector and so on. And the second TABLE
will be use to iterate through the vector's values.

<LI>Inside a table of level 1.

In this case the TABLE iterate through the matrix lines. First iteration
will use the first matrix's vector, second iteration will use second
matrix's vector and so on. Each vector is then converted to a string by
concatenating all values and using the supplied separator (see Assoc
constructor for Matrix_Tag).

<LI>Outside a table statement.

In this case the matrix is converted to a string. Each line represent a
vector converted as a string using the supplied separator (see point 2
above), and each vector is separated by an ASCII.LF character.

</OL>

<P>
Let's look at an example, with the following template:

</P>

<PRE>

A matrix <B>in</B>side a table <B>of</B> level 2:

@@TABLE@@
&#60;tr&#62;
@@TABLE@@
&#60;td&#62;
@_MAT_@
&#60;/td&#62;
@@END_TABLE@@
&#60;/tr&#62;

@@END_TABLE@@

The same matrix <B>in</B>side a single table:

@@TABLE@@
&#60;tr&#62;
&#60;td&#62;
@_MAT_@
&#60;/tr&#62;

@@END_TABLE@@

The same matrix <B>out</B>side a table:

@_MAT_@

</PRE>

<P>
Using the program:

</P>

<PRE>

<B>with</B> Ada.Text_IO;
<B>with</B> Templates_Parser;

<B>procedure</B> Matrix <B>is</B>

   <B>package</B> TP renames Templates_Parser;

   <B>use</B> <B>type</B> TP.Vector_Tag;
   <B>use</B> <B>type</B> TP.Matrix_Tag;

   V1 : <B>constant</B> TP.Vector_Tag := +"<I>A1.1</I>" &#38; "<I>A1.2</I>";
   V2 : <B>constant</B> TP.Vector_Tag := +"<I>A2.1</I>" &#38; "<I>A2.2</I>";
   V3 : <B>constant</B> TP.Vector_Tag := +"<I>A3.1</I>" &#38; "<I>A3.2</I>";

   M  : <B>constant</B> TP.Matrix_Tag := +V1 &#38; V2 &#38; V3;

<B>begin</B>
   Ada.Text_IO.Put_Line
     (TP.Parse ("<I>matrix.tmplt</I>",
                TP.Translate_Table'(1 =&#62; TP.Assoc ("<I>MAT</I>", M))));
<B>end</B> Matrix;

</PRE>

<P>
We get the following result:

</P>

<PRE>

A matrix inside a table of level 2:

&#60;tr&#62;
&#60;td&#62;
A1.1
&#60;/td&#62;
&#60;td&#62;
A1.2
&#60;/td&#62;
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A2.1
&#60;/td&#62;
&#60;td&#62;
A2.2
&#60;/td&#62;
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A3.1
&#60;/td&#62;
&#60;td&#62;
A3.2
&#60;/td&#62;
&#60;/tr&#62;


The same matrix inside a single table:

&#60;tr&#62;
&#60;td&#62;
A1.1, A1.2
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A2.1, A2.2
&#60;/tr&#62;

&#60;tr&#62;
&#60;td&#62;
A3.1, A3.2
&#60;/tr&#62;


The same matrix outside a table:

A1.1, A1.2
A2.1, A2.2
A3.1, A3.2
</PRE>



<H1><A NAME="SEC14" HREF="templates_parser.html#TOC14">Last notes</A></H1>

<P>
The templates parser has be written to parse HTML page but it is usable
with any king of files. There is nothing hard coded for HTML, it is then
possible to use it with plain text files, XML files, SGML files or
whatever as long as it is not a binary file.

</P>
<P>

<P>
All tag statements can be mixed together. A <CODE>table</CODE> tag statement can be
put in a <CODE>if</CODE> tag statement. An <CODE>if</CODE> tag statement can be put
in a <CODE>table</CODE> tag statement. Idem for the <CODE>include</CODE> tag statement.

</P>
<P>
Download page is <A HREF="http://perso.wanadoo.fr/pascal.obry/">http://perso.wanadoo.fr/pascal.obry/</A>.

</P>
<P>



<H1><A NAME="SEC15" HREF="templates_parser.html#TOC15">Templates_Parser Ada spec</A></H1>


<PRE>

------------------------------------------------------------------------------
-- <I>                            Templates Parser                             --</I>
-- <I>                                                                         --</I>
-- <I>                       Copyright (C) 1999 - 2001                         --</I>
-- <I>                              Pascal Obry                                --</I>
-- <I>                                                                         --</I>
-- <I> This library is free software; you can redistribute it and/or modify    --</I>
-- <I> it under the terms of the GNU General Public License as published by    --</I>
-- <I> the Free Software Foundation; either version 2 of the License, or (at   --</I>
-- <I> your option) any later version.                                         --</I>
-- <I>                                                                         --</I>
-- <I> This library is distributed in the hope that it will be useful, but     --</I>
-- <I> WITHOUT ANY WARRANTY; without even the implied warranty of              --</I>
-- <I> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --</I>
-- <I> General Public License for more details.                                --</I>
-- <I>                                                                         --</I>
-- <I> You should have received a copy of the GNU General Public License       --</I>
-- <I> along with this library; if not, write to the Free Software Foundation, --</I>
-- <I> Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --</I>
-- <I>                                                                         --</I>
-- <I> As a special exception, if other files instantiate generics from this   --</I>
-- <I> unit, or you link this unit with other files to produce an executable,  --</I>
-- <I> this  unit  does not  by itself cause  the resulting executable to be   --</I>
-- <I> covered by the GNU General Public License. This exception does not      --</I>
-- <I> however invalidate any other reasons why the executable file  might be  --</I>
-- <I> covered by the  GNU Public License.                                     --</I>
------------------------------------------------------------------------------

-- <I> $Id$</I>

<B>with</B> Ada.Finalization;
<B>with</B> Ada.Strings.Unbounded;

<B>package</B> Templates_Parser <B>is</B>

   <B>use</B> Ada.Strings.Unbounded;

   Template_Error : <B>exception</B>;

   Default_Begin_Tag : <B>constant</B> String := "<I>@_</I>";
   Default_End_Tag   : <B>constant</B> String := "<I>_@</I>";

   Default_Separator : <B>constant</B> String := "<I>, </I>";

   <B>procedure</B> Set_Tag_Separators
     (Start_With : <B>in</B> String := Default_Begin_Tag;
      Stop_With  : <B>in</B> String := Default_End_Tag);
   -- <I> Set the tag separators for the whole session. This should be changed as</I>
   -- <I> the very first API call and should not be changed after.</I>

   ----------------
   -- <I>Vector Tag --</I>
   ----------------

   <B>type</B> Vector_Tag <B>is</B> <B>private</B>;
   -- <I> A vector tag is a set <B>of</B> strings. Note that this object <B>is</B> using a</I>
   -- <I> by-reference semantic. A reference counter <B>is</B> associated to it and</I>
   -- <I> the memory is realeased when there <B>is</B> no more reference to it.</I>

   <B>function</B> "<I>+</I>" (Value : <B>in</B> String) <B>return</B> Vector_Tag;
   -- <I> Vector_Tag constructor.</I>

   <B>function</B> "<I>+</I>" (Value : <B>in</B> Character) <B>return</B> Vector_Tag;
   -- <I> Vector_Tag constructor.</I>

   <B>function</B> "<I>+</I>" (Value : <B>in</B> Boolean) <B>return</B> Vector_Tag;
   -- <I> Vector_Tag constructor.</I>

   <B>function</B> "<I>+</I>" (Value : <B>in</B> Unbounded_String) <B>return</B> Vector_Tag;
   -- <I> Vector_Tag constructor.</I>

   <B>function</B> "<I>+</I>" (Value : <B>in</B> Integer) <B>return</B> Vector_Tag;
   -- <I> Vector_Tag constructor.</I>

   <B>function</B> "<I>&#38;</I>"
     (Vect  : <B>in</B> Vector_Tag;
      Value : <B>in</B> String)
      <B>return</B> Vector_Tag;
   -- <I> Add Value at the <B>end</B> <B>of</B> the vector tag set.</I>

   <B>function</B> "<I>&#38;</I>"
     (Vect  : <B>in</B> Vector_Tag;
      Value : <B>in</B> Character)
      <B>return</B> Vector_Tag;
   -- <I> Add Value at the <B>end</B> <B>of</B> the vector tag set.</I>

   <B>function</B> "<I>&#38;</I>"
     (Vect  : <B>in</B> Vector_Tag;
      Value : <B>in</B> Boolean)
      <B>return</B> Vector_Tag;
   -- <I> Add Value (either string TRUE or FALSE) at the <B>end</B> <B>of</B> the vector tag</I>
   -- <I> set.</I>

   <B>function</B> "<I>&#38;</I>"
     (Vect  : <B>in</B> Vector_Tag;
      Value : <B>in</B> Unbounded_String)
      <B>return</B> Vector_Tag;
   -- <I> Add Value at the <B>end</B> <B>of</B> the vector tag set.</I>

   <B>function</B> "<I>&#38;</I>"
     (Vect  : <B>in</B> Vector_Tag;
      Value : <B>in</B> Integer)
      <B>return</B> Vector_Tag;
   -- <I> Add Value (converted to a String) at the <B>end</B> <B>of</B> the vector tag set.</I>

   <B>procedure</B> Clear (Vect : <B>in</B> <B>out</B> Vector_Tag);
   -- <I> Removes all values <B>in</B> the vector tag. Current Vect <B>is</B> not released but</I>
   -- <I> the <B>return</B>ed object <B>is</B> separated (not using the same reference) from</I>
   -- <I> the original one.</I>

   <B>function</B> Size (Vect : <B>in</B> Vector_Tag) <B>return</B> Natural;
   -- <I> Returns the number <B>of</B> value <B>in</B>to Vect.</I>

   <B>function</B> Item (Vect : in Vector_Tag; N : <B>in</B> Positive) <B>return</B> String;
   -- <I> Returns the Nth Vector Tag's item. Raises Constraint_Error if there <B>is</B></I>
   -- <I> no such Item <B>in</B> the vector (i.e. vector length &#60; N).</I>

   ----------------
   -- <I>Matrix Tag --</I>
   ----------------

   <B>type</B> Matrix_Tag <B>is</B> <B>private</B>;
   -- <I> A matrix tag is a set <B>of</B> vectors. Note that this object <B>is</B> using a</I>
   -- <I> by-reference semantic. A reference counter <B>is</B> associated to it and</I>
   -- <I> the memory is realeased when there <B>is</B> no more reference to it.</I>

   <B>function</B> "<I>+</I>" (Vect : <B>in</B> Vector_Tag) <B>return</B> Matrix_Tag;
   -- <I> Matrix_Tag constructor. It <B>return</B>s a matrix <B>with</B> a single row whose</I>
   -- <I> value <B>is</B> Vect.</I>

   <B>function</B> "<I>&#38;</I>"
     (Matrix : <B>in</B> Matrix_Tag;
      Vect   : <B>in</B> Vector_Tag)
      <B>return</B> Matrix_Tag;
   -- <I> Returns Matrix <B>with</B> Vect added to the <B>end</B>.</I>

   <B>function</B> Size (Matrix : <B>in</B> Matrix_Tag) <B>return</B> Natural;
   -- <I> Returns the number <B>of</B> Vector_Tag (rows) <B>in</B>side the Matrix.</I>

   <B>function</B> Vector (Matrix : in Matrix_Tag; N : <B>in</B> Positive) <B>return</B> Vector_Tag;
   -- <I> Returns Nth Vector_Tag <B>in</B> the Matrix. Raises Constraint_Error if there</I>
   -- <I> <B>is</B> no such vector <B>in</B> the matrix.</I>

   -----------------------
   -- <I>Association table --</I>
   -----------------------

   <B>type</B> Association <B>is</B> <B>private</B>;

   <B>type</B> Association_Kind <B>is</B> (Std, Vect, Matrix);
   -- <I> The kind <B>of</B> association which <B>is</B> either Std (a simple value), a vector</I>
   -- <I> tag or a Matrix tag.</I>

   <B>type</B> Translate_Table <B>is</B> <B>array</B> (Positive <B>range</B> &#60;&#62;) <B>of</B> Association;

   No_Translation : <B>constant</B> Translate_Table;

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> String)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value <B>is</B> a string.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Unbounded_String)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value <B>is</B> an</I>
   -- <I> Unbounded_String.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Integer)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a standard association, value <B>is</B> an Integer.</I>
   -- <I> It will be displayed <B>with</B>out leading space if positive.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Boolean)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. It set the variable to TRUE or FALSE depending on</I>
   -- <I> value.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Vector_Tag;
      Separator : <B>in</B> String     := Default_Separator)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a vector tag association, value <B>is</B> a</I>
   -- <I> Vector_Tag. If the vector tag <B>is</B> found <B>out</B>side a table tag statement</I>
   -- <I> it <B>is</B> <B>return</B>ed as a single string, each value being separated by the</I>
   -- <I> specified separator.</I>

   <B>function</B> Assoc
     (Variable  : <B>in</B> String;
      Value     : <B>in</B> Matrix_Tag;
      Separator : <B>in</B> String     := Default_Separator)
      <B>return</B> Association;
   -- <I> Build an Association (Variable = Value) to be added to a</I>
   -- <I> Translate_Table. This is a matrix tag association, value <B>is</B> a</I>
   -- <I> Matrix_Tag. If the matrix tag <B>is</B> found <B>out</B>side <B>of</B> a 2nd level table tag</I>
   -- <I> statement, Separator <B>is</B> <B>use</B>d to build string representation <B>of</B> the</I>
   -- <I> matrix tag's vectors.</I>

   -----------------------------
   -- <I>Parsing and Translating --</I>
   -----------------------------

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Table := No_Translation;
      Cached            : <B>in</B> Boolean         := False;
      Keep_Unknown_Tags : <B>in</B> Boolean         := False)
      <B>return</B> String;
   -- <I> Parse the Template_File replacing variables' occurrences by the</I>
   -- <I> corresponding values. If Cached <B>is</B> set to True, Filename tree will be</I>
   -- <I> <B>record</B>ed <B>in</B>to a cache for quick retrieval. If Keep_Unknown_Tags <B>is</B> set</I>
   -- <I> to True then tags that are not <B>in</B> the translate table are kept</I>
   -- <I> as-is if it is part of the template data. If this tags <B>is</B> part <B>of</B> a</I>
   -- <I> condition (in an IF statement tag), the condition will evaluate to</I>
   -- <I> False.</I>

   <B>function</B> Parse
     (Filename          : <B>in</B> String;
      Translations      : <B>in</B> Translate_Table := No_Translation;
      Cached            : <B>in</B> Boolean         := False;
      Keep_Unknown_Tags : <B>in</B> Boolean         := False)
      <B>return</B> Unbounded_String;
   -- <I> Idem as above but <B>return</B>s an Unbounded_String.</I>

   <B>function</B> Translate
     (Template     : <B>in</B> String;
      Translations : <B>in</B> Translate_Table := No_Translation)
      <B>return</B> String;
   -- <I> Just translate the discrete variables <B>in</B> the Template string using the</I>
   -- <I> Translations table. This <B>function</B> does not parse the command tag</I>
   -- <I> (TABLE, IF, INCLUDE). All Vector and Matrix tag are replaced by the</I>
   -- <I> empty string.</I>

   <B>procedure</B> Print_Tree (Filename : <B>in</B> String);
   -- <I> Use for debugging purpose only, it will <B>out</B>put the <B>in</B>ternal tree</I>
   -- <I> representation.</I>

<B>private</B>

   ------------------
   -- <I> Vector Tags --</I>
   ------------------

   <B>type</B> Vector_Tag_Node;
   <B>type</B> Vector_Tag_Node_Access <B>is</B> access Vector_Tag_Node;

   <B>type</B> Vector_Tag_Node <B>is</B> <B>record</B>
      Value : Unbounded_String;
      Next  : Vector_Tag_Node_Access;
   <B>end</B> <B>record</B>;

   <B>type</B> Integer_Access <B>is</B> access Integer;

   <B>type</B> Access_Vector_Tag_Node_Access <B>is</B> access Vector_Tag_Node_Access;

   <B>type</B> Vector_Tag <B>is</B> new Ada.Finalization.Controlled <B>with</B> <B>record</B>
      Ref_Count : Integer_Access;
      Count     : Natural;
      Head      : Vector_Tag_Node_Access;
      Last      : Vector_Tag_Node_Access;
      Current   : Access_Vector_Tag_Node_Access; -- <I>Current/Pos are Iterator</I>
      Pos       : Integer_Access;                -- <I>cache <B>in</B>formation.</I>
   <B>end</B> <B>record</B>;

   <B>type</B> Vector_Tag_Access <B>is</B> access Vector_Tag;

   <B>procedure</B> Initialize (V : <B>in</B> <B>out</B> Vector_Tag);
   <B>procedure</B> Finalize   (V : <B>in</B> <B>out</B> Vector_Tag);
   <B>procedure</B> Adjust     (V : <B>in</B> <B>out</B> Vector_Tag);

   ------------------
   -- <I> Matrix Tags --</I>
   ------------------

   <B>type</B> Matrix_Tag_Node;

   <B>type</B> Matrix_Tag_Node_Access <B>is</B> access Matrix_Tag_Node;

   <B>type</B> Matrix_Tag_Node <B>is</B> <B>record</B>
      Vect : Vector_Tag;
      Next : Matrix_Tag_Node_Access;
   <B>end</B> <B>record</B>;

   <B>type</B> Access_Matrix_Tag_Node_Access <B>is</B> access Matrix_Tag_Node_Access;

   <B>type</B> Matrix_Tag_Int <B>is</B> new Ada.Finalization.Controlled <B>with</B> <B>record</B>
      Ref_Count : Integer_Access;
      Count     : Natural; -- <I>Number <B>of</B> vector</I>
      Min, Max  : Natural; -- <I>Min/Max vector's sizes</I>
      Head      : Matrix_Tag_Node_Access;
      Last      : Matrix_Tag_Node_Access;
      Current   : Access_Matrix_Tag_Node_Access; -- <I>Current/Pos are Iterator</I>
      Pos       : Integer_Access;                -- <I>cahce <B>in</B>formation.</I>
   <B>end</B> <B>record</B>;

   <B>type</B> Matrix_Tag <B>is</B> <B>record</B>
      M : Matrix_Tag_Int;
   <B>end</B> <B>record</B>;

   <B>procedure</B> Initialize (M : <B>in</B> <B>out</B> Matrix_Tag_Int);
   <B>procedure</B> Finalize   (M : <B>in</B> <B>out</B> Matrix_Tag_Int);
   <B>procedure</B> Adjust     (M : <B>in</B> <B>out</B> Matrix_Tag_Int);

   ------------------
   -- <I> Association --</I>
   ------------------

   <B>type</B> Association (Kind : Association_Kind := Std) <B>is</B> <B>record</B>
      Variable  : Unbounded_String;

      case Kind <B>is</B>
         when Std =&#62;
            Value : Unbounded_String;

         when Vect =&#62;
            Vect_Value : Vector_Tag;
            Separator  : Unbounded_String;

         when Matrix =&#62;
            Mat_Value        : Matrix_Tag;
            Column_Separator : Unbounded_String;
      <B>end</B> case;
   <B>end</B> <B>record</B>;

   No_Translation : <B>constant</B> Translate_Table
     := (2 .. 1 =&#62; Association'(Std,
                                Null_Unbounded_String,
                                Null_Unbounded_String));

<B>end</B> Templates_Parser;

</PRE>

<P><HR><P>
This document was generated on 29 November 2003 using the
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>
translator version 1.52.</P>
</BODY>
</HTML>
