#define CVS_ID "$Id$"
/*
   This program is used to get some OS specific settings
*/

#include <stdio.h>
#include <stdlib.h>

#ifdef _WIN32
#define WIN2000SUPPORT
/* We define WIN2000SUPPORT to ensure that executables built with this version
   will run ok on both Win2000 and WinXP.  */
#include <ws2tcpip.h>
#else /* ! _WIN32 */
#include <sys/types.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <errno.h>
#endif

#ifdef sun
#include <sys/filio.h>
#endif

/* For systems without IPv6 support */

#ifndef AI_PASSIVE
#define NO_IPV6_SUPPORT
#define AI_PASSIVE -1
#define AI_CANONNAME -1
#define AI_NUMERICHOST -1
#define EAI_SYSTEM -1
#define PF_INET6 -1
#define AF_INET6 -1
#endif

int
main (int argc, char *argv[])
{
#ifndef NO_IPV6_SUPPORT
  const struct addrinfo ai;

  const void *ai_ptr = &ai;

  const int ai_flags_offset     = (void *)&ai.ai_flags     - ai_ptr;
  const int ai_family_offset    = (void *)&ai.ai_family    - ai_ptr;
  const int ai_socktype_offset  = (void *)&ai.ai_socktype  - ai_ptr;
  const int ai_protocol_offset  = (void *)&ai.ai_protocol  - ai_ptr;
  const int ai_addrlen_offset   = (void *)&ai.ai_addrlen   - ai_ptr;
  const int ai_addr_offset      = (void *)&ai.ai_addr      - ai_ptr;
  const int ai_canonname_offset = (void *)&ai.ai_canonname - ai_ptr;
  const int ai_next_offset      = (void *)&ai.ai_next      - ai_ptr;
#else
  const int ai_flags_offset     = -8;
  const int ai_family_offset    = -7;
  const int ai_socktype_offset  = -6;
  const int ai_protocol_offset  = -5;
  const int ai_addrlen_offset   = -4;
  const int ai_addr_offset      = -3;
  const int ai_canonname_offset = -2;
  const int ai_next_offset      = -1;
#endif

#if defined(__FreeBSD__) || defined(_WIN32)
  const int s_nfds_t = sizeof (int) * 8;
#else
  const int s_nfds_t = sizeof (nfds_t) * 8;
#endif

#ifdef _WIN32
  #define ETIMEDOUT   WSAETIMEDOUT
  #define EWOULDBLOCK WSAEWOULDBLOCK
  #define EINPROGRESS WSAEINPROGRESS
  #define SHUT_RDWR   SD_BOTH
  #define EAI_SYSTEM  EAI_AGAIN
  // EAI_SYSTEM getaddrinfo error code does not supported by Win32, but need
  // for correct error handling, we could use any Win32 socket error code
  // instead, because Win32 use the same error codes in Errno report.

  const char *i_conv      = "Stdcall";
  const int s_fd_type     = sizeof (int) * 8;
  const int s_events_type = sizeof (short) * 8;
  const int v_POLLIN      = 1;
  const int v_POLLPRI     = 2;
  const int v_POLLOUT     = 4;
  const int v_POLLERR     = 8;
  const int v_POLLHUP     = 16;
  const int v_POLLNVAL    = 32;
#else
  const char *i_conv      = "C";
  const struct pollfd v_pollfd;
  const int s_fd_type     = sizeof (v_pollfd.fd) * 8;
  const int s_events_type = sizeof (v_pollfd.events) * 8;
  const int v_POLLIN      = POLLIN;
  const int v_POLLPRI     = POLLPRI;
  const int v_POLLOUT     = POLLOUT;
  const int v_POLLERR     = POLLERR;
  const int v_POLLHUP     = POLLHUP;
  const int v_POLLNVAL    = POLLNVAL;
#endif

  FILE *fd;

  if (argc == 2)
    fd = fopen (argv[1], "wb");
  else
    {
      fprintf (stderr, "Syntax: check_config <filename>\n");
      exit (1);
    }

  fprintf (fd, "\x0a--  AUTOMATICALLY GENERATED, DO NOT EDIT THIS FILE\x0a\x0a");
  fprintf (fd, "--  Generator: %s\x0a\x0a", CVS_ID);
  fprintf (fd, "with Interfaces.C.Strings;\x0a");
  fprintf (fd, "with System;\x0a\x0a");
  fprintf (fd, "package AWS.OS_Lib.Definitions is\x0a\x0a");
  fprintf (fd, "   use Interfaces;\x0a\x0a");

#ifdef _WIN32
  // libaws_win32.a need for emulate some unix routines not available in Win32.
  fprintf (fd, "   pragma Linker_Options (\"-laws_win32\");\x0a");
  // libws2_32.a need for getaddrinfo freeaddrinfo routines in Windows XP/2003.
  fprintf (fd, "   pragma Linker_Options (\"-lws2_32\");\x0a\x0a");
#endif

  /* POLL constants */

  fprintf (fd, "   POLLIN   : constant := %d;\x0a", v_POLLIN);
  fprintf (fd, "   POLLPRI  : constant := %d;\x0a", v_POLLPRI);
  fprintf (fd, "   POLLOUT  : constant := %d;\x0a", v_POLLOUT);
  fprintf (fd, "   POLLERR  : constant := %d;\x0a", v_POLLERR);
  fprintf (fd, "   POLLHUP  : constant := %d;\x0a", v_POLLHUP);
  fprintf (fd, "   POLLNVAL : constant := %d;\x0a\x0a", v_POLLNVAL);

  /* getaddrinfo constants */

  fprintf (fd, "   AI_PASSIVE     : constant := %d;\x0a", AI_PASSIVE);
  fprintf (fd, "   AI_CANONNAME   : constant := %d;\x0a", AI_CANONNAME);
  fprintf (fd, "   AI_NUMERICHOST : constant := %d;\x0a", AI_NUMERICHOST);
  fprintf (fd, "   EAI_SYSTEM     : constant := %d;\x0a\x0a", EAI_SYSTEM);

  /* other constants */

  fprintf (fd, "   IPPROTO_TCP : constant := %d;\n", IPPROTO_TCP);
  fprintf (fd, "   IPPROTO_IP  : constant := %d;\n", IPPROTO_IP);
  fprintf (fd, "   PF_UNSPEC   : constant := %d;\n", PF_UNSPEC);
  fprintf (fd, "   PF_INET     : constant := %d;\n", PF_INET);
  fprintf (fd, "   PF_INET6    : constant := %d;\n", PF_INET6);
  fprintf (fd, "   AF_INET     : constant := %d;\n", AF_INET);
  fprintf (fd, "   AF_INET6    : constant := %d;\n", AF_INET6);
  fprintf (fd, "   SO_ERROR    : constant := %d;\n", SO_ERROR);
  fprintf (fd, "   SO_SNDBUF   : constant := %d;\n", SO_SNDBUF);
  fprintf (fd, "   SO_RCVBUF   : constant := %d;\n", SO_RCVBUF);
  fprintf (fd, "   TCP_NODELAY : constant := %d;\n", TCP_NODELAY);
  fprintf (fd, "   SOCK_STREAM : constant := %d;\n", SOCK_STREAM);
  fprintf (fd, "   SOL_SOCKET  : constant := %d;\n", SOL_SOCKET);
  fprintf (fd, "   SHUT_RDWR   : constant := %d;\n", SHUT_RDWR);
  fprintf (fd, "   ETIMEDOUT   : constant := %d;\n", ETIMEDOUT);
  fprintf (fd, "   EWOULDBLOCK : constant := %d;\n", EWOULDBLOCK);
  fprintf (fd, "   EINPROGRESS : constant := %d;\n", EINPROGRESS);
  fprintf (fd, "   FIONBIO     : constant := %d;\n", FIONBIO);
  fprintf (fd, "   FIONREAD    : constant := %d;\n\n", FIONREAD);

  /* nfds_t */

  fprintf (fd, "   type nfds_t is mod 2 ** %d;\x0a", s_nfds_t);
  fprintf (fd, "   for nfds_t'Size use %d;\x0a\x0a", s_nfds_t);

  /* FD_Type */

  fprintf (fd, "   type FD_Type is mod 2 ** %d;\x0a", s_fd_type);
  fprintf (fd, "   for FD_Type'Size use %d;\x0a\x0a", s_fd_type);

  /* Events_Type */

  fprintf (fd, "   type Events_Type is mod 2 ** %d;\x0a", s_events_type);
  fprintf (fd, "   for Events_Type'Size use %d;\x0a\x0a", s_events_type);

  /* Addr_Info */

  if (ai_flags_offset > 0
      || ai_family_offset    >= ai_socktype_offset
      || ai_socktype_offset  >= ai_protocol_offset
      || ai_addrlen_offset   >= ai_addr_offset
      || ai_addrlen_offset   >= ai_canonname_offset
      || ai_addr_offset      >= ai_next_offset
      || ai_canonname_offset >= ai_next_offset)
      //  Broke source code because of
      fprintf (fd, "   Unexpected addrinfo fields order.");

  fprintf (fd, "   type Addr_Info;\x0a");
  fprintf (fd, "   type Addr_Info_Access is access all Addr_Info;\x0a\x0a");

  fprintf (fd, "   type Addr_Info is record\x0a");
  fprintf (fd, "      ai_flags     : C.int;\x0a");
  fprintf (fd, "      ai_family    : C.int;\x0a");
  fprintf (fd, "      ai_socktype  : C.int;\x0a");
  fprintf (fd, "      ai_protocol  : C.int;\x0a");
  fprintf (fd, "      ai_addrlen   : C.size_t;\x0a");

  if (ai_canonname_offset < ai_addr_offset) {
    //  Linux fields order.

    fprintf (fd, "      ai_canonname : C.Strings.chars_ptr;\x0a");
    fprintf (fd, "      ai_addr      : System.Address;\x0a");
  } else {
    // Win32, FreeBSD, Solaris fields order.

    fprintf (fd, "      ai_addr      : System.Address;\x0a");
    fprintf (fd, "      ai_canonname : C.Strings.chars_ptr;\x0a");
  }

  fprintf (fd, "      ai_next      : Addr_Info_Access;\x0a");
  fprintf (fd, "   end record;\x0a");
  fprintf (fd, "   pragma Convention (C, Addr_Info);\x0a\x0a");

  fprintf (fd, "   function GetAddrInfo\x0a");
  fprintf (fd, "     (node    : in     C.Strings.chars_ptr;\x0a");
  fprintf (fd, "      service : in     C.Strings.chars_ptr;\x0a");
  fprintf (fd, "      hints   : in     Addr_Info;\x0a");
  fprintf (fd, "      res     : access Addr_Info_Access)\x0a");
  fprintf (fd, "      return C.int;\x0a\x0a");

  fprintf (fd, "   procedure FreeAddrInfo (res : in Addr_Info_Access);\x0a\x0a");

  fprintf 
    (fd, "   function GAI_StrError (ecode : in C.int) return C.Strings.chars_ptr;\x0a\x0a");

  fprintf (fd, "   function Set_Sock_Opt\x0a");
  fprintf (fd, "     (S       : in C.int;\x0a");
  fprintf (fd, "      Level   : in C.int;\x0a");
  fprintf (fd, "      OptName : in C.int;\x0a");
  fprintf (fd, "      OptVal  : in System.Address;\x0a");
  fprintf (fd, "      OptLen  : in C.int) return C.int;\x0a\x0a");

  fprintf (fd, "private\x0a\x0a");

#ifdef WIN2000SUPPORT
  fprintf 
    (fd, "   function WSPIAPI_init return Integer;\x0a");
  fprintf 
    (fd, "   pragma Import (C, WSPIAPI_init, \"WSPIAPI_init\");\x0a");
  fprintf 
    (fd, "   Dummy : constant Integer := WSPIAPI_init;\x0a\x0a");

  fprintf 
    (fd, 
     "   pragma Import (Stdcall, GetAddrInfo, \"WspiapiGetAddrInfo\");\x0a");
  fprintf 
    (fd, 
     "   pragma Import (Stdcall, FreeAddrInfo, \"WspiapiFreeAddrInfo\");\x0a");
#else
  fprintf 
    (fd, "   pragma Import (%s, GetAddrInfo, \"getaddrinfo\");\x0a", i_conv);
  fprintf 
    (fd, "   pragma Import (%s, FreeAddrInfo, \"freeaddrinfo\");\x0a", i_conv);
#endif

  // gai_strerror for Win32 inlined in WS2TCPIP.H and is not thread safe.
  // We are using simple replacement in win32/gai_strerror.c

#ifdef _WIN32
  fprintf 
    (fd, "   pragma Import (C, GAI_StrError, \"AWS_gai_strerror\");\x0a\x0a");
#else
  fprintf 
    (fd, "   pragma Import (C, GAI_StrError, \"gai_strerror\");\x0a\x0a");
#endif

  fprintf (fd, "   pragma Import (%s, Set_Sock_Opt, \"setsockopt\");\x0a\x0a", i_conv);

  fprintf (fd, "end AWS.OS_Lib.Definitions;\x0a");
  fclose (fd);

  return 0;
}
